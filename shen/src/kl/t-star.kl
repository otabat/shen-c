"Copyright (c) 2010-2015, Mark Tarver

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice,
this list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation
and/or other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its contributors
may be used to endorse or promote products derived from this software without
specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ''AS IS'' AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
"

(defun shen.typecheck (V3867 V3868) (let Curry (shen.curry V3867) (let ProcessN (shen.start-new-prolog-process) (let Type (shen.insert-prolog-variables (shen.demodulate (shen.curry-type V3868)) ProcessN) (let Continuation (freeze (return Type ProcessN shen.void)) (shen.t* (cons Curry (cons : (cons Type ()))) () ProcessN Continuation))))))

(defun shen.curry (V3870) (cond ((and (cons? V3870) (shen.special? (hd V3870))) (cons (hd V3870) (map (lambda Y (shen.curry Y)) (tl V3870)))) ((and (cons? V3870) (and (cons? (tl V3870)) (shen.extraspecial? (hd V3870)))) V3870) ((and (cons? V3870) (and (= type (hd V3870)) (and (cons? (tl V3870)) (and (cons? (tl (tl V3870))) (= () (tl (tl (tl V3870)))))))) (cons type (cons (shen.curry (hd (tl V3870))) (tl (tl V3870))))) ((and (cons? V3870) (and (cons? (tl V3870)) (cons? (tl (tl V3870))))) (shen.curry (cons (cons (hd V3870) (cons (hd (tl V3870)) ())) (tl (tl V3870))))) ((and (cons? V3870) (and (cons? (tl V3870)) (= () (tl (tl V3870))))) (cons (shen.curry (hd V3870)) (cons (shen.curry (hd (tl V3870))) ()))) (true V3870)))

(defun shen.special? (V3872) (element? V3872 (value shen.*special*)))

(defun shen.extraspecial? (V3874) (element? V3874 (value shen.*extraspecial*)))

(defun shen.t* (V3879 V3880 V3881 V3882) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let Error (shen.newpv V3881) (do (shen.incinfs) (fwhen (shen.maxinfexceeded?) V3881 (freeze (bind Error (shen.errormaxinfs) V3881 V3882))))) (if (= Case false) (let Case (let V3859 (shen.lazyderef V3879 V3881) (if (= fail V3859) (do (shen.incinfs) (cut Throwcontrol V3881 (freeze (shen.prolog-failure V3881 V3882)))) false)) (if (= Case false) (let Case (let V3860 (shen.lazyderef V3879 V3881) (if (cons? V3860) (let X (hd V3860) (let V3861 (shen.lazyderef (tl V3860) V3881) (if (cons? V3861) (let V3862 (shen.lazyderef (hd V3861) V3881) (if (= : V3862) (let V3863 (shen.lazyderef (tl V3861) V3881) (if (cons? V3863) (let A (hd V3863) (let V3864 (shen.lazyderef (tl V3863) V3881) (if (= () V3864) (do (shen.incinfs) (fwhen (shen.type-theory-enabled?) V3881 (freeze (cut Throwcontrol V3881 (freeze (shen.th* X A V3880 V3881 V3882)))))) false))) false)) false)) false))) false)) (if (= Case false) (let Datatypes (shen.newpv V3881) (do (shen.incinfs) (shen.show V3879 V3880 V3881 (freeze (bind Datatypes (value shen.*datatypes*) V3881 (freeze (shen.udefs* V3879 V3880 Datatypes V3881 V3882))))))) Case)) Case)) Case)))))

(defun shen.type-theory-enabled? () (value shen.*shen-type-theory-enabled?*))

(defun enable-type-theory (V3888) (cond ((= + V3888) (set shen.*shen-type-theory-enabled?* true)) ((= - V3888) (set shen.*shen-type-theory-enabled?* false)) (true (simple-error "enable-type-theory expects a + or a -
"))))

(defun shen.prolog-failure (V3899 V3900) false)

(defun shen.maxinfexceeded? () (> (inferences) (value shen.*maxinferences*)))

(defun shen.errormaxinfs () (simple-error "maximum inferences exceeded~%"))

(defun shen.udefs* (V3906 V3907 V3908 V3909 V3910) (let Case (let V3855 (shen.lazyderef V3908 V3909) (if (cons? V3855) (let D (hd V3855) (do (shen.incinfs) (call (cons D (cons V3906 (cons V3907 ()))) V3909 V3910))) false)) (if (= Case false) (let V3856 (shen.lazyderef V3908 V3909) (if (cons? V3856) (let Ds (tl V3856) (do (shen.incinfs) (shen.udefs* V3906 V3907 Ds V3909 V3910))) false)) Case)))

(defun shen.th* (V3916 V3917 V3918 V3919 V3920) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (do (shen.incinfs) (shen.show (cons V3916 (cons : (cons V3917 ()))) V3918 V3919 (freeze (fwhen false V3919 V3920)))) (if (= Case false) (let Case (let F (shen.newpv V3919) (do (shen.incinfs) (fwhen (shen.typedf? (shen.lazyderef V3916 V3919)) V3919 (freeze (bind F (shen.sigf (shen.lazyderef V3916 V3919)) V3919 (freeze (call (cons F (cons V3917 ())) V3919 V3920))))))) (if (= Case false) (let Case (do (shen.incinfs) (shen.base V3916 V3917 V3919 V3920)) (if (= Case false) (let Case (do (shen.incinfs) (shen.by_hypothesis V3916 V3917 V3918 V3919 V3920)) (if (= Case false) (let Case (let V3751 (shen.lazyderef V3916 V3919) (if (cons? V3751) (let F (hd V3751) (let V3752 (shen.lazyderef (tl V3751) V3919) (if (= () V3752) (do (shen.incinfs) (shen.th* F (cons --> (cons V3917 ())) V3918 V3919 V3920)) false))) false)) (if (= Case false) (let Case (let V3753 (shen.lazyderef V3916 V3919) (if (cons? V3753) (let F (hd V3753) (let V3754 (shen.lazyderef (tl V3753) V3919) (if (cons? V3754) (let X (hd V3754) (let V3755 (shen.lazyderef (tl V3754) V3919) (if (= () V3755) (let B (shen.newpv V3919) (do (shen.incinfs) (shen.th* F (cons B (cons --> (cons V3917 ()))) V3918 V3919 (freeze (shen.th* X B V3918 V3919 V3920))))) false))) false))) false)) (if (= Case false) (let Case (let V3756 (shen.lazyderef V3916 V3919) (if (cons? V3756) (let V3757 (shen.lazyderef (hd V3756) V3919) (if (= cons V3757) (let V3758 (shen.lazyderef (tl V3756) V3919) (if (cons? V3758) (let X (hd V3758) (let V3759 (shen.lazyderef (tl V3758) V3919) (if (cons? V3759) (let Y (hd V3759) (let V3760 (shen.lazyderef (tl V3759) V3919) (if (= () V3760) (let V3761 (shen.lazyderef V3917 V3919) (if (cons? V3761) (let V3762 (shen.lazyderef (hd V3761) V3919) (if (= list V3762) (let V3763 (shen.lazyderef (tl V3761) V3919) (if (cons? V3763) (let A (hd V3763) (let V3764 (shen.lazyderef (tl V3763) V3919) (if (= () V3764) (do (shen.incinfs) (shen.th* X A V3918 V3919 (freeze (shen.th* Y (cons list (cons A ())) V3918 V3919 V3920)))) (if (shen.pvar? V3764) (do (shen.bindv V3764 () V3919) (let Result (do (shen.incinfs) (shen.th* X A V3918 V3919 (freeze (shen.th* Y (cons list (cons A ())) V3918 V3919 V3920)))) (do (shen.unbindv V3764 V3919) Result))) false)))) (if (shen.pvar? V3763) (let A (shen.newpv V3919) (do (shen.bindv V3763 (cons A ()) V3919) (let Result (do (shen.incinfs) (shen.th* X A V3918 V3919 (freeze (shen.th* Y (cons list (cons A ())) V3918 V3919 V3920)))) (do (shen.unbindv V3763 V3919) Result)))) false))) (if (shen.pvar? V3762) (do (shen.bindv V3762 list V3919) (let Result (let V3765 (shen.lazyderef (tl V3761) V3919) (if (cons? V3765) (let A (hd V3765) (let V3766 (shen.lazyderef (tl V3765) V3919) (if (= () V3766) (do (shen.incinfs) (shen.th* X A V3918 V3919 (freeze (shen.th* Y (cons list (cons A ())) V3918 V3919 V3920)))) (if (shen.pvar? V3766) (do (shen.bindv V3766 () V3919) (let Result (do (shen.incinfs) (shen.th* X A V3918 V3919 (freeze (shen.th* Y (cons list (cons A ())) V3918 V3919 V3920)))) (do (shen.unbindv V3766 V3919) Result))) false)))) (if (shen.pvar? V3765) (let A (shen.newpv V3919) (do (shen.bindv V3765 (cons A ()) V3919) (let Result (do (shen.incinfs) (shen.th* X A V3918 V3919 (freeze (shen.th* Y (cons list (cons A ())) V3918 V3919 V3920)))) (do (shen.unbindv V3765 V3919) Result)))) false))) (do (shen.unbindv V3762 V3919) Result))) false))) (if (shen.pvar? V3761) (let A (shen.newpv V3919) (do (shen.bindv V3761 (cons list (cons A ())) V3919) (let Result (do (shen.incinfs) (shen.th* X A V3918 V3919 (freeze (shen.th* Y (cons list (cons A ())) V3918 V3919 V3920)))) (do (shen.unbindv V3761 V3919) Result)))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V3767 (shen.lazyderef V3916 V3919) (if (cons? V3767) (let V3768 (shen.lazyderef (hd V3767) V3919) (if (= @p V3768) (let V3769 (shen.lazyderef (tl V3767) V3919) (if (cons? V3769) (let X (hd V3769) (let V3770 (shen.lazyderef (tl V3769) V3919) (if (cons? V3770) (let Y (hd V3770) (let V3771 (shen.lazyderef (tl V3770) V3919) (if (= () V3771) (let V3772 (shen.lazyderef V3917 V3919) (if (cons? V3772) (let A (hd V3772) (let V3773 (shen.lazyderef (tl V3772) V3919) (if (cons? V3773) (let V3774 (shen.lazyderef (hd V3773) V3919) (if (= * V3774) (let V3775 (shen.lazyderef (tl V3773) V3919) (if (cons? V3775) (let B (hd V3775) (let V3776 (shen.lazyderef (tl V3775) V3919) (if (= () V3776) (do (shen.incinfs) (shen.th* X A V3918 V3919 (freeze (shen.th* Y B V3918 V3919 V3920)))) (if (shen.pvar? V3776) (do (shen.bindv V3776 () V3919) (let Result (do (shen.incinfs) (shen.th* X A V3918 V3919 (freeze (shen.th* Y B V3918 V3919 V3920)))) (do (shen.unbindv V3776 V3919) Result))) false)))) (if (shen.pvar? V3775) (let B (shen.newpv V3919) (do (shen.bindv V3775 (cons B ()) V3919) (let Result (do (shen.incinfs) (shen.th* X A V3918 V3919 (freeze (shen.th* Y B V3918 V3919 V3920)))) (do (shen.unbindv V3775 V3919) Result)))) false))) (if (shen.pvar? V3774) (do (shen.bindv V3774 * V3919) (let Result (let V3777 (shen.lazyderef (tl V3773) V3919) (if (cons? V3777) (let B (hd V3777) (let V3778 (shen.lazyderef (tl V3777) V3919) (if (= () V3778) (do (shen.incinfs) (shen.th* X A V3918 V3919 (freeze (shen.th* Y B V3918 V3919 V3920)))) (if (shen.pvar? V3778) (do (shen.bindv V3778 () V3919) (let Result (do (shen.incinfs) (shen.th* X A V3918 V3919 (freeze (shen.th* Y B V3918 V3919 V3920)))) (do (shen.unbindv V3778 V3919) Result))) false)))) (if (shen.pvar? V3777) (let B (shen.newpv V3919) (do (shen.bindv V3777 (cons B ()) V3919) (let Result (do (shen.incinfs) (shen.th* X A V3918 V3919 (freeze (shen.th* Y B V3918 V3919 V3920)))) (do (shen.unbindv V3777 V3919) Result)))) false))) (do (shen.unbindv V3774 V3919) Result))) false))) (if (shen.pvar? V3773) (let B (shen.newpv V3919) (do (shen.bindv V3773 (cons * (cons B ())) V3919) (let Result (do (shen.incinfs) (shen.th* X A V3918 V3919 (freeze (shen.th* Y B V3918 V3919 V3920)))) (do (shen.unbindv V3773 V3919) Result)))) false)))) (if (shen.pvar? V3772) (let A (shen.newpv V3919) (let B (shen.newpv V3919) (do (shen.bindv V3772 (cons A (cons * (cons B ()))) V3919) (let Result (do (shen.incinfs) (shen.th* X A V3918 V3919 (freeze (shen.th* Y B V3918 V3919 V3920)))) (do (shen.unbindv V3772 V3919) Result))))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V3779 (shen.lazyderef V3916 V3919) (if (cons? V3779) (let V3780 (shen.lazyderef (hd V3779) V3919) (if (= @v V3780) (let V3781 (shen.lazyderef (tl V3779) V3919) (if (cons? V3781) (let X (hd V3781) (let V3782 (shen.lazyderef (tl V3781) V3919) (if (cons? V3782) (let Y (hd V3782) (let V3783 (shen.lazyderef (tl V3782) V3919) (if (= () V3783) (let V3784 (shen.lazyderef V3917 V3919) (if (cons? V3784) (let V3785 (shen.lazyderef (hd V3784) V3919) (if (= vector V3785) (let V3786 (shen.lazyderef (tl V3784) V3919) (if (cons? V3786) (let A (hd V3786) (let V3787 (shen.lazyderef (tl V3786) V3919) (if (= () V3787) (do (shen.incinfs) (shen.th* X A V3918 V3919 (freeze (shen.th* Y (cons vector (cons A ())) V3918 V3919 V3920)))) (if (shen.pvar? V3787) (do (shen.bindv V3787 () V3919) (let Result (do (shen.incinfs) (shen.th* X A V3918 V3919 (freeze (shen.th* Y (cons vector (cons A ())) V3918 V3919 V3920)))) (do (shen.unbindv V3787 V3919) Result))) false)))) (if (shen.pvar? V3786) (let A (shen.newpv V3919) (do (shen.bindv V3786 (cons A ()) V3919) (let Result (do (shen.incinfs) (shen.th* X A V3918 V3919 (freeze (shen.th* Y (cons vector (cons A ())) V3918 V3919 V3920)))) (do (shen.unbindv V3786 V3919) Result)))) false))) (if (shen.pvar? V3785) (do (shen.bindv V3785 vector V3919) (let Result (let V3788 (shen.lazyderef (tl V3784) V3919) (if (cons? V3788) (let A (hd V3788) (let V3789 (shen.lazyderef (tl V3788) V3919) (if (= () V3789) (do (shen.incinfs) (shen.th* X A V3918 V3919 (freeze (shen.th* Y (cons vector (cons A ())) V3918 V3919 V3920)))) (if (shen.pvar? V3789) (do (shen.bindv V3789 () V3919) (let Result (do (shen.incinfs) (shen.th* X A V3918 V3919 (freeze (shen.th* Y (cons vector (cons A ())) V3918 V3919 V3920)))) (do (shen.unbindv V3789 V3919) Result))) false)))) (if (shen.pvar? V3788) (let A (shen.newpv V3919) (do (shen.bindv V3788 (cons A ()) V3919) (let Result (do (shen.incinfs) (shen.th* X A V3918 V3919 (freeze (shen.th* Y (cons vector (cons A ())) V3918 V3919 V3920)))) (do (shen.unbindv V3788 V3919) Result)))) false))) (do (shen.unbindv V3785 V3919) Result))) false))) (if (shen.pvar? V3784) (let A (shen.newpv V3919) (do (shen.bindv V3784 (cons vector (cons A ())) V3919) (let Result (do (shen.incinfs) (shen.th* X A V3918 V3919 (freeze (shen.th* Y (cons vector (cons A ())) V3918 V3919 V3920)))) (do (shen.unbindv V3784 V3919) Result)))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V3790 (shen.lazyderef V3916 V3919) (if (cons? V3790) (let V3791 (shen.lazyderef (hd V3790) V3919) (if (= @s V3791) (let V3792 (shen.lazyderef (tl V3790) V3919) (if (cons? V3792) (let X (hd V3792) (let V3793 (shen.lazyderef (tl V3792) V3919) (if (cons? V3793) (let Y (hd V3793) (let V3794 (shen.lazyderef (tl V3793) V3919) (if (= () V3794) (let V3795 (shen.lazyderef V3917 V3919) (if (= string V3795) (do (shen.incinfs) (shen.th* X string V3918 V3919 (freeze (shen.th* Y string V3918 V3919 V3920)))) (if (shen.pvar? V3795) (do (shen.bindv V3795 string V3919) (let Result (do (shen.incinfs) (shen.th* X string V3918 V3919 (freeze (shen.th* Y string V3918 V3919 V3920)))) (do (shen.unbindv V3795 V3919) Result))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V3796 (shen.lazyderef V3916 V3919) (if (cons? V3796) (let V3797 (shen.lazyderef (hd V3796) V3919) (if (= lambda V3797) (let V3798 (shen.lazyderef (tl V3796) V3919) (if (cons? V3798) (let X (hd V3798) (let V3799 (shen.lazyderef (tl V3798) V3919) (if (cons? V3799) (let Y (hd V3799) (let V3800 (shen.lazyderef (tl V3799) V3919) (if (= () V3800) (let V3801 (shen.lazyderef V3917 V3919) (if (cons? V3801) (let A (hd V3801) (let V3802 (shen.lazyderef (tl V3801) V3919) (if (cons? V3802) (let V3803 (shen.lazyderef (hd V3802) V3919) (if (= --> V3803) (let V3804 (shen.lazyderef (tl V3802) V3919) (if (cons? V3804) (let B (hd V3804) (let V3805 (shen.lazyderef (tl V3804) V3919) (if (= () V3805) (let Z (shen.newpv V3919) (let X&& (shen.newpv V3919) (do (shen.incinfs) (bind X&& (shen.placeholder) V3919 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V3919) (shen.lazyderef X V3919) (shen.lazyderef Y V3919)) V3919 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V3918) V3919 V3920)))))))) (if (shen.pvar? V3805) (do (shen.bindv V3805 () V3919) (let Result (let Z (shen.newpv V3919) (let X&& (shen.newpv V3919) (do (shen.incinfs) (bind X&& (shen.placeholder) V3919 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V3919) (shen.lazyderef X V3919) (shen.lazyderef Y V3919)) V3919 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V3918) V3919 V3920)))))))) (do (shen.unbindv V3805 V3919) Result))) false)))) (if (shen.pvar? V3804) (let B (shen.newpv V3919) (do (shen.bindv V3804 (cons B ()) V3919) (let Result (let Z (shen.newpv V3919) (let X&& (shen.newpv V3919) (do (shen.incinfs) (bind X&& (shen.placeholder) V3919 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V3919) (shen.lazyderef X V3919) (shen.lazyderef Y V3919)) V3919 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V3918) V3919 V3920)))))))) (do (shen.unbindv V3804 V3919) Result)))) false))) (if (shen.pvar? V3803) (do (shen.bindv V3803 --> V3919) (let Result (let V3806 (shen.lazyderef (tl V3802) V3919) (if (cons? V3806) (let B (hd V3806) (let V3807 (shen.lazyderef (tl V3806) V3919) (if (= () V3807) (let Z (shen.newpv V3919) (let X&& (shen.newpv V3919) (do (shen.incinfs) (bind X&& (shen.placeholder) V3919 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V3919) (shen.lazyderef X V3919) (shen.lazyderef Y V3919)) V3919 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V3918) V3919 V3920)))))))) (if (shen.pvar? V3807) (do (shen.bindv V3807 () V3919) (let Result (let Z (shen.newpv V3919) (let X&& (shen.newpv V3919) (do (shen.incinfs) (bind X&& (shen.placeholder) V3919 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V3919) (shen.lazyderef X V3919) (shen.lazyderef Y V3919)) V3919 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V3918) V3919 V3920)))))))) (do (shen.unbindv V3807 V3919) Result))) false)))) (if (shen.pvar? V3806) (let B (shen.newpv V3919) (do (shen.bindv V3806 (cons B ()) V3919) (let Result (let Z (shen.newpv V3919) (let X&& (shen.newpv V3919) (do (shen.incinfs) (bind X&& (shen.placeholder) V3919 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V3919) (shen.lazyderef X V3919) (shen.lazyderef Y V3919)) V3919 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V3918) V3919 V3920)))))))) (do (shen.unbindv V3806 V3919) Result)))) false))) (do (shen.unbindv V3803 V3919) Result))) false))) (if (shen.pvar? V3802) (let B (shen.newpv V3919) (do (shen.bindv V3802 (cons --> (cons B ())) V3919) (let Result (let Z (shen.newpv V3919) (let X&& (shen.newpv V3919) (do (shen.incinfs) (bind X&& (shen.placeholder) V3919 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V3919) (shen.lazyderef X V3919) (shen.lazyderef Y V3919)) V3919 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V3918) V3919 V3920)))))))) (do (shen.unbindv V3802 V3919) Result)))) false)))) (if (shen.pvar? V3801) (let A (shen.newpv V3919) (let B (shen.newpv V3919) (do (shen.bindv V3801 (cons A (cons --> (cons B ()))) V3919) (let Result (let Z (shen.newpv V3919) (let X&& (shen.newpv V3919) (do (shen.incinfs) (bind X&& (shen.placeholder) V3919 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V3919) (shen.lazyderef X V3919) (shen.lazyderef Y V3919)) V3919 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V3918) V3919 V3920)))))))) (do (shen.unbindv V3801 V3919) Result))))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V3808 (shen.lazyderef V3916 V3919) (if (cons? V3808) (let V3809 (shen.lazyderef (hd V3808) V3919) (if (= let V3809) (let V3810 (shen.lazyderef (tl V3808) V3919) (if (cons? V3810) (let X (hd V3810) (let V3811 (shen.lazyderef (tl V3810) V3919) (if (cons? V3811) (let Y (hd V3811) (let V3812 (shen.lazyderef (tl V3811) V3919) (if (cons? V3812) (let Z (hd V3812) (let V3813 (shen.lazyderef (tl V3812) V3919) (if (= () V3813) (let W (shen.newpv V3919) (let X&& (shen.newpv V3919) (let B (shen.newpv V3919) (do (shen.incinfs) (shen.th* Y B V3918 V3919 (freeze (bind X&& (shen.placeholder) V3919 (freeze (bind W (shen.ebr (shen.lazyderef X&& V3919) (shen.lazyderef X V3919) (shen.lazyderef Z V3919)) V3919 (freeze (shen.th* W V3917 (cons (cons X&& (cons : (cons B ()))) V3918) V3919 V3920))))))))))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V3814 (shen.lazyderef V3916 V3919) (if (cons? V3814) (let V3815 (shen.lazyderef (hd V3814) V3919) (if (= open V3815) (let V3816 (shen.lazyderef (tl V3814) V3919) (if (cons? V3816) (let FileName (hd V3816) (let V3817 (shen.lazyderef (tl V3816) V3919) (if (cons? V3817) (let Direction3747 (hd V3817) (let V3818 (shen.lazyderef (tl V3817) V3919) (if (= () V3818) (let V3819 (shen.lazyderef V3917 V3919) (if (cons? V3819) (let V3820 (shen.lazyderef (hd V3819) V3919) (if (= stream V3820) (let V3821 (shen.lazyderef (tl V3819) V3919) (if (cons? V3821) (let Direction (hd V3821) (let V3822 (shen.lazyderef (tl V3821) V3919) (if (= () V3822) (do (shen.incinfs) (unify! Direction Direction3747 V3919 (freeze (cut Throwcontrol V3919 (freeze (fwhen (element? (shen.lazyderef Direction V3919) (cons in (cons out ()))) V3919 (freeze (shen.th* FileName string V3918 V3919 V3920)))))))) (if (shen.pvar? V3822) (do (shen.bindv V3822 () V3919) (let Result (do (shen.incinfs) (unify! Direction Direction3747 V3919 (freeze (cut Throwcontrol V3919 (freeze (fwhen (element? (shen.lazyderef Direction V3919) (cons in (cons out ()))) V3919 (freeze (shen.th* FileName string V3918 V3919 V3920)))))))) (do (shen.unbindv V3822 V3919) Result))) false)))) (if (shen.pvar? V3821) (let Direction (shen.newpv V3919) (do (shen.bindv V3821 (cons Direction ()) V3919) (let Result (do (shen.incinfs) (unify! Direction Direction3747 V3919 (freeze (cut Throwcontrol V3919 (freeze (fwhen (element? (shen.lazyderef Direction V3919) (cons in (cons out ()))) V3919 (freeze (shen.th* FileName string V3918 V3919 V3920)))))))) (do (shen.unbindv V3821 V3919) Result)))) false))) (if (shen.pvar? V3820) (do (shen.bindv V3820 stream V3919) (let Result (let V3823 (shen.lazyderef (tl V3819) V3919) (if (cons? V3823) (let Direction (hd V3823) (let V3824 (shen.lazyderef (tl V3823) V3919) (if (= () V3824) (do (shen.incinfs) (unify! Direction Direction3747 V3919 (freeze (cut Throwcontrol V3919 (freeze (fwhen (element? (shen.lazyderef Direction V3919) (cons in (cons out ()))) V3919 (freeze (shen.th* FileName string V3918 V3919 V3920)))))))) (if (shen.pvar? V3824) (do (shen.bindv V3824 () V3919) (let Result (do (shen.incinfs) (unify! Direction Direction3747 V3919 (freeze (cut Throwcontrol V3919 (freeze (fwhen (element? (shen.lazyderef Direction V3919) (cons in (cons out ()))) V3919 (freeze (shen.th* FileName string V3918 V3919 V3920)))))))) (do (shen.unbindv V3824 V3919) Result))) false)))) (if (shen.pvar? V3823) (let Direction (shen.newpv V3919) (do (shen.bindv V3823 (cons Direction ()) V3919) (let Result (do (shen.incinfs) (unify! Direction Direction3747 V3919 (freeze (cut Throwcontrol V3919 (freeze (fwhen (element? (shen.lazyderef Direction V3919) (cons in (cons out ()))) V3919 (freeze (shen.th* FileName string V3918 V3919 V3920)))))))) (do (shen.unbindv V3823 V3919) Result)))) false))) (do (shen.unbindv V3820 V3919) Result))) false))) (if (shen.pvar? V3819) (let Direction (shen.newpv V3919) (do (shen.bindv V3819 (cons stream (cons Direction ())) V3919) (let Result (do (shen.incinfs) (unify! Direction Direction3747 V3919 (freeze (cut Throwcontrol V3919 (freeze (fwhen (element? (shen.lazyderef Direction V3919) (cons in (cons out ()))) V3919 (freeze (shen.th* FileName string V3918 V3919 V3920)))))))) (do (shen.unbindv V3819 V3919) Result)))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V3825 (shen.lazyderef V3916 V3919) (if (cons? V3825) (let V3826 (shen.lazyderef (hd V3825) V3919) (if (= type V3826) (let V3827 (shen.lazyderef (tl V3825) V3919) (if (cons? V3827) (let X (hd V3827) (let V3828 (shen.lazyderef (tl V3827) V3919) (if (cons? V3828) (let A (hd V3828) (let V3829 (shen.lazyderef (tl V3828) V3919) (if (= () V3829) (do (shen.incinfs) (cut Throwcontrol V3919 (freeze (unify A V3917 V3919 (freeze (shen.th* X A V3918 V3919 V3920)))))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V3830 (shen.lazyderef V3916 V3919) (if (cons? V3830) (let V3831 (shen.lazyderef (hd V3830) V3919) (if (= input+ V3831) (let V3832 (shen.lazyderef (tl V3830) V3919) (if (cons? V3832) (let A (hd V3832) (let V3833 (shen.lazyderef (tl V3832) V3919) (if (cons? V3833) (let Stream (hd V3833) (let V3834 (shen.lazyderef (tl V3833) V3919) (if (= () V3834) (let C (shen.newpv V3919) (do (shen.incinfs) (bind C (shen.demodulate (shen.lazyderef A V3919)) V3919 (freeze (unify V3917 C V3919 (freeze (shen.th* Stream (cons stream (cons in ())) V3918 V3919 V3920))))))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V3835 (shen.lazyderef V3916 V3919) (if (cons? V3835) (let V3836 (shen.lazyderef (hd V3835) V3919) (if (= set V3836) (let V3837 (shen.lazyderef (tl V3835) V3919) (if (cons? V3837) (let Var (hd V3837) (let V3838 (shen.lazyderef (tl V3837) V3919) (if (cons? V3838) (let Val (hd V3838) (let V3839 (shen.lazyderef (tl V3838) V3919) (if (= () V3839) (do (shen.incinfs) (cut Throwcontrol V3919 (freeze (shen.th* Var symbol V3918 V3919 (freeze (cut Throwcontrol V3919 (freeze (shen.th* (cons value (cons Var ())) V3917 V3918 V3919 (freeze (shen.th* Val V3917 V3918 V3919 V3920)))))))))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let NewHyp (shen.newpv V3919) (do (shen.incinfs) (shen.t*-hyps V3918 NewHyp V3919 (freeze (shen.th* V3916 V3917 NewHyp V3919 V3920))))) (if (= Case false) (let Case (let V3840 (shen.lazyderef V3916 V3919) (if (cons? V3840) (let V3841 (shen.lazyderef (hd V3840) V3919) (if (= define V3841) (let V3842 (shen.lazyderef (tl V3840) V3919) (if (cons? V3842) (let F (hd V3842) (let X (tl V3842) (do (shen.incinfs) (cut Throwcontrol V3919 (freeze (shen.t*-def (cons define (cons F X)) V3917 V3918 V3919 V3920)))))) false)) false)) false)) (if (= Case false) (let Case (let V3843 (shen.lazyderef V3916 V3919) (if (cons? V3843) (let V3844 (shen.lazyderef (hd V3843) V3919) (if (= defmacro V3844) (let V3845 (shen.lazyderef V3917 V3919) (if (= unit V3845) (do (shen.incinfs) (cut Throwcontrol V3919 V3920)) (if (shen.pvar? V3845) (do (shen.bindv V3845 unit V3919) (let Result (do (shen.incinfs) (cut Throwcontrol V3919 V3920)) (do (shen.unbindv V3845 V3919) Result))) false))) false)) false)) (if (= Case false) (let Case (let V3846 (shen.lazyderef V3916 V3919) (if (cons? V3846) (let V3847 (shen.lazyderef (hd V3846) V3919) (if (= shen.process-datatype V3847) (let V3848 (shen.lazyderef V3917 V3919) (if (= symbol V3848) (do (shen.incinfs) (thaw V3920)) (if (shen.pvar? V3848) (do (shen.bindv V3848 symbol V3919) (let Result (do (shen.incinfs) (thaw V3920)) (do (shen.unbindv V3848 V3919) Result))) false))) false)) false)) (if (= Case false) (let Case (let V3849 (shen.lazyderef V3916 V3919) (if (cons? V3849) (let V3850 (shen.lazyderef (hd V3849) V3919) (if (= shen.synonyms-help V3850) (let V3851 (shen.lazyderef V3917 V3919) (if (= symbol V3851) (do (shen.incinfs) (thaw V3920)) (if (shen.pvar? V3851) (do (shen.bindv V3851 symbol V3919) (let Result (do (shen.incinfs) (thaw V3920)) (do (shen.unbindv V3851 V3919) Result))) false))) false)) false)) (if (= Case false) (let Datatypes (shen.newpv V3919) (do (shen.incinfs) (bind Datatypes (value shen.*datatypes*) V3919 (freeze (shen.udefs* (cons V3916 (cons : (cons V3917 ()))) V3918 Datatypes V3919 V3920))))) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)))))

(defun shen.t*-hyps (V3925 V3926 V3927 V3928) (let Case (let V3662 (shen.lazyderef V3925 V3927) (if (cons? V3662) (let V3663 (shen.lazyderef (hd V3662) V3927) (if (cons? V3663) (let V3664 (shen.lazyderef (hd V3663) V3927) (if (cons? V3664) (let V3665 (shen.lazyderef (hd V3664) V3927) (if (= cons V3665) (let V3666 (shen.lazyderef (tl V3664) V3927) (if (cons? V3666) (let X (hd V3666) (let V3667 (shen.lazyderef (tl V3666) V3927) (if (cons? V3667) (let Y (hd V3667) (let V3668 (shen.lazyderef (tl V3667) V3927) (if (= () V3668) (let V3669 (shen.lazyderef (tl V3663) V3927) (if (cons? V3669) (let V3670 (shen.lazyderef (hd V3669) V3927) (if (= : V3670) (let V3671 (shen.lazyderef (tl V3669) V3927) (if (cons? V3671) (let V3672 (shen.lazyderef (hd V3671) V3927) (if (cons? V3672) (let V3673 (shen.lazyderef (hd V3672) V3927) (if (= list V3673) (let V3674 (shen.lazyderef (tl V3672) V3927) (if (cons? V3674) (let A (hd V3674) (let V3675 (shen.lazyderef (tl V3674) V3927) (if (= () V3675) (let V3676 (shen.lazyderef (tl V3671) V3927) (if (= () V3676) (let Hyp (tl V3662) (do (shen.incinfs) (bind V3926 (cons (cons (shen.lazyderef X V3927) (cons : (cons (shen.lazyderef A V3927) ()))) (cons (cons (shen.lazyderef Y V3927) (cons : (cons (cons list (cons (shen.lazyderef A V3927) ())) ()))) (shen.lazyderef Hyp V3927))) V3927 V3928))) (if (shen.pvar? V3676) (do (shen.bindv V3676 () V3927) (let Result (let Hyp (tl V3662) (do (shen.incinfs) (bind V3926 (cons (cons (shen.lazyderef X V3927) (cons : (cons (shen.lazyderef A V3927) ()))) (cons (cons (shen.lazyderef Y V3927) (cons : (cons (cons list (cons (shen.lazyderef A V3927) ())) ()))) (shen.lazyderef Hyp V3927))) V3927 V3928))) (do (shen.unbindv V3676 V3927) Result))) false))) (if (shen.pvar? V3675) (do (shen.bindv V3675 () V3927) (let Result (let V3677 (shen.lazyderef (tl V3671) V3927) (if (= () V3677) (let Hyp (tl V3662) (do (shen.incinfs) (bind V3926 (cons (cons (shen.lazyderef X V3927) (cons : (cons (shen.lazyderef A V3927) ()))) (cons (cons (shen.lazyderef Y V3927) (cons : (cons (cons list (cons (shen.lazyderef A V3927) ())) ()))) (shen.lazyderef Hyp V3927))) V3927 V3928))) (if (shen.pvar? V3677) (do (shen.bindv V3677 () V3927) (let Result (let Hyp (tl V3662) (do (shen.incinfs) (bind V3926 (cons (cons (shen.lazyderef X V3927) (cons : (cons (shen.lazyderef A V3927) ()))) (cons (cons (shen.lazyderef Y V3927) (cons : (cons (cons list (cons (shen.lazyderef A V3927) ())) ()))) (shen.lazyderef Hyp V3927))) V3927 V3928))) (do (shen.unbindv V3677 V3927) Result))) false))) (do (shen.unbindv V3675 V3927) Result))) false)))) (if (shen.pvar? V3674) (let A (shen.newpv V3927) (do (shen.bindv V3674 (cons A ()) V3927) (let Result (let V3678 (shen.lazyderef (tl V3671) V3927) (if (= () V3678) (let Hyp (tl V3662) (do (shen.incinfs) (bind V3926 (cons (cons (shen.lazyderef X V3927) (cons : (cons (shen.lazyderef A V3927) ()))) (cons (cons (shen.lazyderef Y V3927) (cons : (cons (cons list (cons (shen.lazyderef A V3927) ())) ()))) (shen.lazyderef Hyp V3927))) V3927 V3928))) (if (shen.pvar? V3678) (do (shen.bindv V3678 () V3927) (let Result (let Hyp (tl V3662) (do (shen.incinfs) (bind V3926 (cons (cons (shen.lazyderef X V3927) (cons : (cons (shen.lazyderef A V3927) ()))) (cons (cons (shen.lazyderef Y V3927) (cons : (cons (cons list (cons (shen.lazyderef A V3927) ())) ()))) (shen.lazyderef Hyp V3927))) V3927 V3928))) (do (shen.unbindv V3678 V3927) Result))) false))) (do (shen.unbindv V3674 V3927) Result)))) false))) (if (shen.pvar? V3673) (do (shen.bindv V3673 list V3927) (let Result (let V3679 (shen.lazyderef (tl V3672) V3927) (if (cons? V3679) (let A (hd V3679) (let V3680 (shen.lazyderef (tl V3679) V3927) (if (= () V3680) (let V3681 (shen.lazyderef (tl V3671) V3927) (if (= () V3681) (let Hyp (tl V3662) (do (shen.incinfs) (bind V3926 (cons (cons (shen.lazyderef X V3927) (cons : (cons (shen.lazyderef A V3927) ()))) (cons (cons (shen.lazyderef Y V3927) (cons : (cons (cons list (cons (shen.lazyderef A V3927) ())) ()))) (shen.lazyderef Hyp V3927))) V3927 V3928))) (if (shen.pvar? V3681) (do (shen.bindv V3681 () V3927) (let Result (let Hyp (tl V3662) (do (shen.incinfs) (bind V3926 (cons (cons (shen.lazyderef X V3927) (cons : (cons (shen.lazyderef A V3927) ()))) (cons (cons (shen.lazyderef Y V3927) (cons : (cons (cons list (cons (shen.lazyderef A V3927) ())) ()))) (shen.lazyderef Hyp V3927))) V3927 V3928))) (do (shen.unbindv V3681 V3927) Result))) false))) (if (shen.pvar? V3680) (do (shen.bindv V3680 () V3927) (let Result (let V3682 (shen.lazyderef (tl V3671) V3927) (if (= () V3682) (let Hyp (tl V3662) (do (shen.incinfs) (bind V3926 (cons (cons (shen.lazyderef X V3927) (cons : (cons (shen.lazyderef A V3927) ()))) (cons (cons (shen.lazyderef Y V3927) (cons : (cons (cons list (cons (shen.lazyderef A V3927) ())) ()))) (shen.lazyderef Hyp V3927))) V3927 V3928))) (if (shen.pvar? V3682) (do (shen.bindv V3682 () V3927) (let Result (let Hyp (tl V3662) (do (shen.incinfs) (bind V3926 (cons (cons (shen.lazyderef X V3927) (cons : (cons (shen.lazyderef A V3927) ()))) (cons (cons (shen.lazyderef Y V3927) (cons : (cons (cons list (cons (shen.lazyderef A V3927) ())) ()))) (shen.lazyderef Hyp V3927))) V3927 V3928))) (do (shen.unbindv V3682 V3927) Result))) false))) (do (shen.unbindv V3680 V3927) Result))) false)))) (if (shen.pvar? V3679) (let A (shen.newpv V3927) (do (shen.bindv V3679 (cons A ()) V3927) (let Result (let V3683 (shen.lazyderef (tl V3671) V3927) (if (= () V3683) (let Hyp (tl V3662) (do (shen.incinfs) (bind V3926 (cons (cons (shen.lazyderef X V3927) (cons : (cons (shen.lazyderef A V3927) ()))) (cons (cons (shen.lazyderef Y V3927) (cons : (cons (cons list (cons (shen.lazyderef A V3927) ())) ()))) (shen.lazyderef Hyp V3927))) V3927 V3928))) (if (shen.pvar? V3683) (do (shen.bindv V3683 () V3927) (let Result (let Hyp (tl V3662) (do (shen.incinfs) (bind V3926 (cons (cons (shen.lazyderef X V3927) (cons : (cons (shen.lazyderef A V3927) ()))) (cons (cons (shen.lazyderef Y V3927) (cons : (cons (cons list (cons (shen.lazyderef A V3927) ())) ()))) (shen.lazyderef Hyp V3927))) V3927 V3928))) (do (shen.unbindv V3683 V3927) Result))) false))) (do (shen.unbindv V3679 V3927) Result)))) false))) (do (shen.unbindv V3673 V3927) Result))) false))) (if (shen.pvar? V3672) (let A (shen.newpv V3927) (do (shen.bindv V3672 (cons list (cons A ())) V3927) (let Result (let V3684 (shen.lazyderef (tl V3671) V3927) (if (= () V3684) (let Hyp (tl V3662) (do (shen.incinfs) (bind V3926 (cons (cons (shen.lazyderef X V3927) (cons : (cons (shen.lazyderef A V3927) ()))) (cons (cons (shen.lazyderef Y V3927) (cons : (cons (cons list (cons (shen.lazyderef A V3927) ())) ()))) (shen.lazyderef Hyp V3927))) V3927 V3928))) (if (shen.pvar? V3684) (do (shen.bindv V3684 () V3927) (let Result (let Hyp (tl V3662) (do (shen.incinfs) (bind V3926 (cons (cons (shen.lazyderef X V3927) (cons : (cons (shen.lazyderef A V3927) ()))) (cons (cons (shen.lazyderef Y V3927) (cons : (cons (cons list (cons (shen.lazyderef A V3927) ())) ()))) (shen.lazyderef Hyp V3927))) V3927 V3928))) (do (shen.unbindv V3684 V3927) Result))) false))) (do (shen.unbindv V3672 V3927) Result)))) false))) false)) false)) false)) false))) false))) false)) false)) false)) false)) false)) (if (= Case false) (let Case (let V3685 (shen.lazyderef V3925 V3927) (if (cons? V3685) (let V3686 (shen.lazyderef (hd V3685) V3927) (if (cons? V3686) (let V3687 (shen.lazyderef (hd V3686) V3927) (if (cons? V3687) (let V3688 (shen.lazyderef (hd V3687) V3927) (if (= @p V3688) (let V3689 (shen.lazyderef (tl V3687) V3927) (if (cons? V3689) (let X (hd V3689) (let V3690 (shen.lazyderef (tl V3689) V3927) (if (cons? V3690) (let Y (hd V3690) (let V3691 (shen.lazyderef (tl V3690) V3927) (if (= () V3691) (let V3692 (shen.lazyderef (tl V3686) V3927) (if (cons? V3692) (let V3693 (shen.lazyderef (hd V3692) V3927) (if (= : V3693) (let V3694 (shen.lazyderef (tl V3692) V3927) (if (cons? V3694) (let V3695 (shen.lazyderef (hd V3694) V3927) (if (cons? V3695) (let A (hd V3695) (let V3696 (shen.lazyderef (tl V3695) V3927) (if (cons? V3696) (let V3697 (shen.lazyderef (hd V3696) V3927) (if (= * V3697) (let V3698 (shen.lazyderef (tl V3696) V3927) (if (cons? V3698) (let B (hd V3698) (let V3699 (shen.lazyderef (tl V3698) V3927) (if (= () V3699) (let V3700 (shen.lazyderef (tl V3694) V3927) (if (= () V3700) (let Hyp (tl V3685) (do (shen.incinfs) (bind V3926 (cons (cons (shen.lazyderef X V3927) (cons : (cons (shen.lazyderef A V3927) ()))) (cons (cons (shen.lazyderef Y V3927) (cons : (cons (shen.lazyderef B V3927) ()))) (shen.lazyderef Hyp V3927))) V3927 V3928))) (if (shen.pvar? V3700) (do (shen.bindv V3700 () V3927) (let Result (let Hyp (tl V3685) (do (shen.incinfs) (bind V3926 (cons (cons (shen.lazyderef X V3927) (cons : (cons (shen.lazyderef A V3927) ()))) (cons (cons (shen.lazyderef Y V3927) (cons : (cons (shen.lazyderef B V3927) ()))) (shen.lazyderef Hyp V3927))) V3927 V3928))) (do (shen.unbindv V3700 V3927) Result))) false))) (if (shen.pvar? V3699) (do (shen.bindv V3699 () V3927) (let Result (let V3701 (shen.lazyderef (tl V3694) V3927) (if (= () V3701) (let Hyp (tl V3685) (do (shen.incinfs) (bind V3926 (cons (cons (shen.lazyderef X V3927) (cons : (cons (shen.lazyderef A V3927) ()))) (cons (cons (shen.lazyderef Y V3927) (cons : (cons (shen.lazyderef B V3927) ()))) (shen.lazyderef Hyp V3927))) V3927 V3928))) (if (shen.pvar? V3701) (do (shen.bindv V3701 () V3927) (let Result (let Hyp (tl V3685) (do (shen.incinfs) (bind V3926 (cons (cons (shen.lazyderef X V3927) (cons : (cons (shen.lazyderef A V3927) ()))) (cons (cons (shen.lazyderef Y V3927) (cons : (cons (shen.lazyderef B V3927) ()))) (shen.lazyderef Hyp V3927))) V3927 V3928))) (do (shen.unbindv V3701 V3927) Result))) false))) (do (shen.unbindv V3699 V3927) Result))) false)))) (if (shen.pvar? V3698) (let B (shen.newpv V3927) (do (shen.bindv V3698 (cons B ()) V3927) (let Result (let V3702 (shen.lazyderef (tl V3694) V3927) (if (= () V3702) (let Hyp (tl V3685) (do (shen.incinfs) (bind V3926 (cons (cons (shen.lazyderef X V3927) (cons : (cons (shen.lazyderef A V3927) ()))) (cons (cons (shen.lazyderef Y V3927) (cons : (cons (shen.lazyderef B V3927) ()))) (shen.lazyderef Hyp V3927))) V3927 V3928))) (if (shen.pvar? V3702) (do (shen.bindv V3702 () V3927) (let Result (let Hyp (tl V3685) (do (shen.incinfs) (bind V3926 (cons (cons (shen.lazyderef X V3927) (cons : (cons (shen.lazyderef A V3927) ()))) (cons (cons (shen.lazyderef Y V3927) (cons : (cons (shen.lazyderef B V3927) ()))) (shen.lazyderef Hyp V3927))) V3927 V3928))) (do (shen.unbindv V3702 V3927) Result))) false))) (do (shen.unbindv V3698 V3927) Result)))) false))) (if (shen.pvar? V3697) (do (shen.bindv V3697 * V3927) (let Result (let V3703 (shen.lazyderef (tl V3696) V3927) (if (cons? V3703) (let B (hd V3703) (let V3704 (shen.lazyderef (tl V3703) V3927) (if (= () V3704) (let V3705 (shen.lazyderef (tl V3694) V3927) (if (= () V3705) (let Hyp (tl V3685) (do (shen.incinfs) (bind V3926 (cons (cons (shen.lazyderef X V3927) (cons : (cons (shen.lazyderef A V3927) ()))) (cons (cons (shen.lazyderef Y V3927) (cons : (cons (shen.lazyderef B V3927) ()))) (shen.lazyderef Hyp V3927))) V3927 V3928))) (if (shen.pvar? V3705) (do (shen.bindv V3705 () V3927) (let Result (let Hyp (tl V3685) (do (shen.incinfs) (bind V3926 (cons (cons (shen.lazyderef X V3927) (cons : (cons (shen.lazyderef A V3927) ()))) (cons (cons (shen.lazyderef Y V3927) (cons : (cons (shen.lazyderef B V3927) ()))) (shen.lazyderef Hyp V3927))) V3927 V3928))) (do (shen.unbindv V3705 V3927) Result))) false))) (if (shen.pvar? V3704) (do (shen.bindv V3704 () V3927) (let Result (let V3706 (shen.lazyderef (tl V3694) V3927) (if (= () V3706) (let Hyp (tl V3685) (do (shen.incinfs) (bind V3926 (cons (cons (shen.lazyderef X V3927) (cons : (cons (shen.lazyderef A V3927) ()))) (cons (cons (shen.lazyderef Y V3927) (cons : (cons (shen.lazyderef B V3927) ()))) (shen.lazyderef Hyp V3927))) V3927 V3928))) (if (shen.pvar? V3706) (do (shen.bindv V3706 () V3927) (let Result (let Hyp (tl V3685) (do (shen.incinfs) (bind V3926 (cons (cons (shen.lazyderef X V3927) (cons : (cons (shen.lazyderef A V3927) ()))) (cons (cons (shen.lazyderef Y V3927) (cons : (cons (shen.lazyderef B V3927) ()))) (shen.lazyderef Hyp V3927))) V3927 V3928))) (do (shen.unbindv V3706 V3927) Result))) false))) (do (shen.unbindv V3704 V3927) Result))) false)))) (if (shen.pvar? V3703) (let B (shen.newpv V3927) (do (shen.bindv V3703 (cons B ()) V3927) (let Result (let V3707 (shen.lazyderef (tl V3694) V3927) (if (= () V3707) (let Hyp (tl V3685) (do (shen.incinfs) (bind V3926 (cons (cons (shen.lazyderef X V3927) (cons : (cons (shen.lazyderef A V3927) ()))) (cons (cons (shen.lazyderef Y V3927) (cons : (cons (shen.lazyderef B V3927) ()))) (shen.lazyderef Hyp V3927))) V3927 V3928))) (if (shen.pvar? V3707) (do (shen.bindv V3707 () V3927) (let Result (let Hyp (tl V3685) (do (shen.incinfs) (bind V3926 (cons (cons (shen.lazyderef X V3927) (cons : (cons (shen.lazyderef A V3927) ()))) (cons (cons (shen.lazyderef Y V3927) (cons : (cons (shen.lazyderef B V3927) ()))) (shen.lazyderef Hyp V3927))) V3927 V3928))) (do (shen.unbindv V3707 V3927) Result))) false))) (do (shen.unbindv V3703 V3927) Result)))) false))) (do (shen.unbindv V3697 V3927) Result))) false))) (if (shen.pvar? V3696) (let B (shen.newpv V3927) (do (shen.bindv V3696 (cons * (cons B ())) V3927) (let Result (let V3708 (shen.lazyderef (tl V3694) V3927) (if (= () V3708) (let Hyp (tl V3685) (do (shen.incinfs) (bind V3926 (cons (cons (shen.lazyderef X V3927) (cons : (cons (shen.lazyderef A V3927) ()))) (cons (cons (shen.lazyderef Y V3927) (cons : (cons (shen.lazyderef B V3927) ()))) (shen.lazyderef Hyp V3927))) V3927 V3928))) (if (shen.pvar? V3708) (do (shen.bindv V3708 () V3927) (let Result (let Hyp (tl V3685) (do (shen.incinfs) (bind V3926 (cons (cons (shen.lazyderef X V3927) (cons : (cons (shen.lazyderef A V3927) ()))) (cons (cons (shen.lazyderef Y V3927) (cons : (cons (shen.lazyderef B V3927) ()))) (shen.lazyderef Hyp V3927))) V3927 V3928))) (do (shen.unbindv V3708 V3927) Result))) false))) (do (shen.unbindv V3696 V3927) Result)))) false)))) (if (shen.pvar? V3695) (let A (shen.newpv V3927) (let B (shen.newpv V3927) (do (shen.bindv V3695 (cons A (cons * (cons B ()))) V3927) (let Result (let V3709 (shen.lazyderef (tl V3694) V3927) (if (= () V3709) (let Hyp (tl V3685) (do (shen.incinfs) (bind V3926 (cons (cons (shen.lazyderef X V3927) (cons : (cons (shen.lazyderef A V3927) ()))) (cons (cons (shen.lazyderef Y V3927) (cons : (cons (shen.lazyderef B V3927) ()))) (shen.lazyderef Hyp V3927))) V3927 V3928))) (if (shen.pvar? V3709) (do (shen.bindv V3709 () V3927) (let Result (let Hyp (tl V3685) (do (shen.incinfs) (bind V3926 (cons (cons (shen.lazyderef X V3927) (cons : (cons (shen.lazyderef A V3927) ()))) (cons (cons (shen.lazyderef Y V3927) (cons : (cons (shen.lazyderef B V3927) ()))) (shen.lazyderef Hyp V3927))) V3927 V3928))) (do (shen.unbindv V3709 V3927) Result))) false))) (do (shen.unbindv V3695 V3927) Result))))) false))) false)) false)) false)) false))) false))) false)) false)) false)) false)) false)) (if (= Case false) (let Case (let V3710 (shen.lazyderef V3925 V3927) (if (cons? V3710) (let V3711 (shen.lazyderef (hd V3710) V3927) (if (cons? V3711) (let V3712 (shen.lazyderef (hd V3711) V3927) (if (cons? V3712) (let V3713 (shen.lazyderef (hd V3712) V3927) (if (= @v V3713) (let V3714 (shen.lazyderef (tl V3712) V3927) (if (cons? V3714) (let X (hd V3714) (let V3715 (shen.lazyderef (tl V3714) V3927) (if (cons? V3715) (let Y (hd V3715) (let V3716 (shen.lazyderef (tl V3715) V3927) (if (= () V3716) (let V3717 (shen.lazyderef (tl V3711) V3927) (if (cons? V3717) (let V3718 (shen.lazyderef (hd V3717) V3927) (if (= : V3718) (let V3719 (shen.lazyderef (tl V3717) V3927) (if (cons? V3719) (let V3720 (shen.lazyderef (hd V3719) V3927) (if (cons? V3720) (let V3721 (shen.lazyderef (hd V3720) V3927) (if (= vector V3721) (let V3722 (shen.lazyderef (tl V3720) V3927) (if (cons? V3722) (let A (hd V3722) (let V3723 (shen.lazyderef (tl V3722) V3927) (if (= () V3723) (let V3724 (shen.lazyderef (tl V3719) V3927) (if (= () V3724) (let Hyp (tl V3710) (do (shen.incinfs) (bind V3926 (cons (cons (shen.lazyderef X V3927) (cons : (cons (shen.lazyderef A V3927) ()))) (cons (cons (shen.lazyderef Y V3927) (cons : (cons (cons vector (cons (shen.lazyderef A V3927) ())) ()))) (shen.lazyderef Hyp V3927))) V3927 V3928))) (if (shen.pvar? V3724) (do (shen.bindv V3724 () V3927) (let Result (let Hyp (tl V3710) (do (shen.incinfs) (bind V3926 (cons (cons (shen.lazyderef X V3927) (cons : (cons (shen.lazyderef A V3927) ()))) (cons (cons (shen.lazyderef Y V3927) (cons : (cons (cons vector (cons (shen.lazyderef A V3927) ())) ()))) (shen.lazyderef Hyp V3927))) V3927 V3928))) (do (shen.unbindv V3724 V3927) Result))) false))) (if (shen.pvar? V3723) (do (shen.bindv V3723 () V3927) (let Result (let V3725 (shen.lazyderef (tl V3719) V3927) (if (= () V3725) (let Hyp (tl V3710) (do (shen.incinfs) (bind V3926 (cons (cons (shen.lazyderef X V3927) (cons : (cons (shen.lazyderef A V3927) ()))) (cons (cons (shen.lazyderef Y V3927) (cons : (cons (cons vector (cons (shen.lazyderef A V3927) ())) ()))) (shen.lazyderef Hyp V3927))) V3927 V3928))) (if (shen.pvar? V3725) (do (shen.bindv V3725 () V3927) (let Result (let Hyp (tl V3710) (do (shen.incinfs) (bind V3926 (cons (cons (shen.lazyderef X V3927) (cons : (cons (shen.lazyderef A V3927) ()))) (cons (cons (shen.lazyderef Y V3927) (cons : (cons (cons vector (cons (shen.lazyderef A V3927) ())) ()))) (shen.lazyderef Hyp V3927))) V3927 V3928))) (do (shen.unbindv V3725 V3927) Result))) false))) (do (shen.unbindv V3723 V3927) Result))) false)))) (if (shen.pvar? V3722) (let A (shen.newpv V3927) (do (shen.bindv V3722 (cons A ()) V3927) (let Result (let V3726 (shen.lazyderef (tl V3719) V3927) (if (= () V3726) (let Hyp (tl V3710) (do (shen.incinfs) (bind V3926 (cons (cons (shen.lazyderef X V3927) (cons : (cons (shen.lazyderef A V3927) ()))) (cons (cons (shen.lazyderef Y V3927) (cons : (cons (cons vector (cons (shen.lazyderef A V3927) ())) ()))) (shen.lazyderef Hyp V3927))) V3927 V3928))) (if (shen.pvar? V3726) (do (shen.bindv V3726 () V3927) (let Result (let Hyp (tl V3710) (do (shen.incinfs) (bind V3926 (cons (cons (shen.lazyderef X V3927) (cons : (cons (shen.lazyderef A V3927) ()))) (cons (cons (shen.lazyderef Y V3927) (cons : (cons (cons vector (cons (shen.lazyderef A V3927) ())) ()))) (shen.lazyderef Hyp V3927))) V3927 V3928))) (do (shen.unbindv V3726 V3927) Result))) false))) (do (shen.unbindv V3722 V3927) Result)))) false))) (if (shen.pvar? V3721) (do (shen.bindv V3721 vector V3927) (let Result (let V3727 (shen.lazyderef (tl V3720) V3927) (if (cons? V3727) (let A (hd V3727) (let V3728 (shen.lazyderef (tl V3727) V3927) (if (= () V3728) (let V3729 (shen.lazyderef (tl V3719) V3927) (if (= () V3729) (let Hyp (tl V3710) (do (shen.incinfs) (bind V3926 (cons (cons (shen.lazyderef X V3927) (cons : (cons (shen.lazyderef A V3927) ()))) (cons (cons (shen.lazyderef Y V3927) (cons : (cons (cons vector (cons (shen.lazyderef A V3927) ())) ()))) (shen.lazyderef Hyp V3927))) V3927 V3928))) (if (shen.pvar? V3729) (do (shen.bindv V3729 () V3927) (let Result (let Hyp (tl V3710) (do (shen.incinfs) (bind V3926 (cons (cons (shen.lazyderef X V3927) (cons : (cons (shen.lazyderef A V3927) ()))) (cons (cons (shen.lazyderef Y V3927) (cons : (cons (cons vector (cons (shen.lazyderef A V3927) ())) ()))) (shen.lazyderef Hyp V3927))) V3927 V3928))) (do (shen.unbindv V3729 V3927) Result))) false))) (if (shen.pvar? V3728) (do (shen.bindv V3728 () V3927) (let Result (let V3730 (shen.lazyderef (tl V3719) V3927) (if (= () V3730) (let Hyp (tl V3710) (do (shen.incinfs) (bind V3926 (cons (cons (shen.lazyderef X V3927) (cons : (cons (shen.lazyderef A V3927) ()))) (cons (cons (shen.lazyderef Y V3927) (cons : (cons (cons vector (cons (shen.lazyderef A V3927) ())) ()))) (shen.lazyderef Hyp V3927))) V3927 V3928))) (if (shen.pvar? V3730) (do (shen.bindv V3730 () V3927) (let Result (let Hyp (tl V3710) (do (shen.incinfs) (bind V3926 (cons (cons (shen.lazyderef X V3927) (cons : (cons (shen.lazyderef A V3927) ()))) (cons (cons (shen.lazyderef Y V3927) (cons : (cons (cons vector (cons (shen.lazyderef A V3927) ())) ()))) (shen.lazyderef Hyp V3927))) V3927 V3928))) (do (shen.unbindv V3730 V3927) Result))) false))) (do (shen.unbindv V3728 V3927) Result))) false)))) (if (shen.pvar? V3727) (let A (shen.newpv V3927) (do (shen.bindv V3727 (cons A ()) V3927) (let Result (let V3731 (shen.lazyderef (tl V3719) V3927) (if (= () V3731) (let Hyp (tl V3710) (do (shen.incinfs) (bind V3926 (cons (cons (shen.lazyderef X V3927) (cons : (cons (shen.lazyderef A V3927) ()))) (cons (cons (shen.lazyderef Y V3927) (cons : (cons (cons vector (cons (shen.lazyderef A V3927) ())) ()))) (shen.lazyderef Hyp V3927))) V3927 V3928))) (if (shen.pvar? V3731) (do (shen.bindv V3731 () V3927) (let Result (let Hyp (tl V3710) (do (shen.incinfs) (bind V3926 (cons (cons (shen.lazyderef X V3927) (cons : (cons (shen.lazyderef A V3927) ()))) (cons (cons (shen.lazyderef Y V3927) (cons : (cons (cons vector (cons (shen.lazyderef A V3927) ())) ()))) (shen.lazyderef Hyp V3927))) V3927 V3928))) (do (shen.unbindv V3731 V3927) Result))) false))) (do (shen.unbindv V3727 V3927) Result)))) false))) (do (shen.unbindv V3721 V3927) Result))) false))) (if (shen.pvar? V3720) (let A (shen.newpv V3927) (do (shen.bindv V3720 (cons vector (cons A ())) V3927) (let Result (let V3732 (shen.lazyderef (tl V3719) V3927) (if (= () V3732) (let Hyp (tl V3710) (do (shen.incinfs) (bind V3926 (cons (cons (shen.lazyderef X V3927) (cons : (cons (shen.lazyderef A V3927) ()))) (cons (cons (shen.lazyderef Y V3927) (cons : (cons (cons vector (cons (shen.lazyderef A V3927) ())) ()))) (shen.lazyderef Hyp V3927))) V3927 V3928))) (if (shen.pvar? V3732) (do (shen.bindv V3732 () V3927) (let Result (let Hyp (tl V3710) (do (shen.incinfs) (bind V3926 (cons (cons (shen.lazyderef X V3927) (cons : (cons (shen.lazyderef A V3927) ()))) (cons (cons (shen.lazyderef Y V3927) (cons : (cons (cons vector (cons (shen.lazyderef A V3927) ())) ()))) (shen.lazyderef Hyp V3927))) V3927 V3928))) (do (shen.unbindv V3732 V3927) Result))) false))) (do (shen.unbindv V3720 V3927) Result)))) false))) false)) false)) false)) false))) false))) false)) false)) false)) false)) false)) (if (= Case false) (let Case (let V3733 (shen.lazyderef V3925 V3927) (if (cons? V3733) (let V3734 (shen.lazyderef (hd V3733) V3927) (if (cons? V3734) (let V3735 (shen.lazyderef (hd V3734) V3927) (if (cons? V3735) (let V3736 (shen.lazyderef (hd V3735) V3927) (if (= @s V3736) (let V3737 (shen.lazyderef (tl V3735) V3927) (if (cons? V3737) (let X (hd V3737) (let V3738 (shen.lazyderef (tl V3737) V3927) (if (cons? V3738) (let Y (hd V3738) (let V3739 (shen.lazyderef (tl V3738) V3927) (if (= () V3739) (let V3740 (shen.lazyderef (tl V3734) V3927) (if (cons? V3740) (let V3741 (shen.lazyderef (hd V3740) V3927) (if (= : V3741) (let V3742 (shen.lazyderef (tl V3740) V3927) (if (cons? V3742) (let V3743 (shen.lazyderef (hd V3742) V3927) (if (= string V3743) (let V3744 (shen.lazyderef (tl V3742) V3927) (if (= () V3744) (let Hyp (tl V3733) (do (shen.incinfs) (bind V3926 (cons (cons (shen.lazyderef X V3927) (cons : (cons string ()))) (cons (cons (shen.lazyderef Y V3927) (cons : (cons string ()))) (shen.lazyderef Hyp V3927))) V3927 V3928))) (if (shen.pvar? V3744) (do (shen.bindv V3744 () V3927) (let Result (let Hyp (tl V3733) (do (shen.incinfs) (bind V3926 (cons (cons (shen.lazyderef X V3927) (cons : (cons string ()))) (cons (cons (shen.lazyderef Y V3927) (cons : (cons string ()))) (shen.lazyderef Hyp V3927))) V3927 V3928))) (do (shen.unbindv V3744 V3927) Result))) false))) (if (shen.pvar? V3743) (do (shen.bindv V3743 string V3927) (let Result (let V3745 (shen.lazyderef (tl V3742) V3927) (if (= () V3745) (let Hyp (tl V3733) (do (shen.incinfs) (bind V3926 (cons (cons (shen.lazyderef X V3927) (cons : (cons string ()))) (cons (cons (shen.lazyderef Y V3927) (cons : (cons string ()))) (shen.lazyderef Hyp V3927))) V3927 V3928))) (if (shen.pvar? V3745) (do (shen.bindv V3745 () V3927) (let Result (let Hyp (tl V3733) (do (shen.incinfs) (bind V3926 (cons (cons (shen.lazyderef X V3927) (cons : (cons string ()))) (cons (cons (shen.lazyderef Y V3927) (cons : (cons string ()))) (shen.lazyderef Hyp V3927))) V3927 V3928))) (do (shen.unbindv V3745 V3927) Result))) false))) (do (shen.unbindv V3743 V3927) Result))) false))) false)) false)) false)) false))) false))) false)) false)) false)) false)) false)) (if (= Case false) (let V3746 (shen.lazyderef V3925 V3927) (if (cons? V3746) (let X (hd V3746) (let Hyp (tl V3746) (let NewHyps (shen.newpv V3927) (do (shen.incinfs) (bind V3926 (cons (shen.lazyderef X V3927) (shen.lazyderef NewHyps V3927)) V3927 (freeze (shen.t*-hyps Hyp NewHyps V3927 V3928))))))) false)) Case)) Case)) Case)) Case)))

(defun shen.show (V3945 V3946 V3947 V3948) (cond ((value shen.*spy*) (do (shen.line) (do (shen.show-p (shen.deref V3945 V3947)) (do (nl 1) (do (nl 1) (do (shen.show-assumptions (shen.deref V3946 V3947) 1) (do (shen.prhush "
> " (stoutput)) (do (shen.pause-for-user) (thaw V3948))))))))) (true (thaw V3948))))

(defun shen.line () (let Infs (inferences) (shen.prhush (cn "____________________________________________________________ " (shen.app Infs (cn " inference" (shen.app (if (= 1 Infs) "" "s") " 
?- " shen.a)) shen.a)) (stoutput))))

(defun shen.show-p (V3950) (cond ((and (cons? V3950) (and (cons? (tl V3950)) (and (= : (hd (tl V3950))) (and (cons? (tl (tl V3950))) (= () (tl (tl (tl V3950)))))))) (shen.prhush (shen.app (hd V3950) (cn " : " (shen.app (hd (tl (tl V3950))) "" shen.r)) shen.r) (stoutput))) (true (shen.prhush (shen.app V3950 "" shen.r) (stoutput)))))

(defun shen.show-assumptions (V3955 V3956) (cond ((= () V3955) shen.skip) ((cons? V3955) (do (shen.prhush (shen.app V3956 ". " shen.a) (stoutput)) (do (shen.show-p (hd V3955)) (do (nl 1) (shen.show-assumptions (tl V3955) (+ V3956 1)))))) (true (shen.f_error shen.show-assumptions))))

(defun shen.pause-for-user () (let Byte (read-byte (stinput)) (if (= Byte 94) (simple-error "input aborted
") (nl 1))))

(defun shen.typedf? (V3958) (cons? (assoc V3958 (value shen.*signedfuncs*))))

(defun shen.sigf (V3960) (concat shen.type-signature-of- V3960))

(defun shen.placeholder () (gensym &&))

(defun shen.base (V3965 V3966 V3967 V3968) (let Case (let V3649 (shen.lazyderef V3966 V3967) (if (= number V3649) (do (shen.incinfs) (fwhen (number? (shen.lazyderef V3965 V3967)) V3967 V3968)) (if (shen.pvar? V3649) (do (shen.bindv V3649 number V3967) (let Result (do (shen.incinfs) (fwhen (number? (shen.lazyderef V3965 V3967)) V3967 V3968)) (do (shen.unbindv V3649 V3967) Result))) false))) (if (= Case false) (let Case (let V3650 (shen.lazyderef V3966 V3967) (if (= boolean V3650) (do (shen.incinfs) (fwhen (boolean? (shen.lazyderef V3965 V3967)) V3967 V3968)) (if (shen.pvar? V3650) (do (shen.bindv V3650 boolean V3967) (let Result (do (shen.incinfs) (fwhen (boolean? (shen.lazyderef V3965 V3967)) V3967 V3968)) (do (shen.unbindv V3650 V3967) Result))) false))) (if (= Case false) (let Case (let V3651 (shen.lazyderef V3966 V3967) (if (= string V3651) (do (shen.incinfs) (fwhen (string? (shen.lazyderef V3965 V3967)) V3967 V3968)) (if (shen.pvar? V3651) (do (shen.bindv V3651 string V3967) (let Result (do (shen.incinfs) (fwhen (string? (shen.lazyderef V3965 V3967)) V3967 V3968)) (do (shen.unbindv V3651 V3967) Result))) false))) (if (= Case false) (let Case (let V3652 (shen.lazyderef V3966 V3967) (if (= symbol V3652) (do (shen.incinfs) (fwhen (symbol? (shen.lazyderef V3965 V3967)) V3967 (freeze (fwhen (not (shen.ue? (shen.lazyderef V3965 V3967))) V3967 V3968)))) (if (shen.pvar? V3652) (do (shen.bindv V3652 symbol V3967) (let Result (do (shen.incinfs) (fwhen (symbol? (shen.lazyderef V3965 V3967)) V3967 (freeze (fwhen (not (shen.ue? (shen.lazyderef V3965 V3967))) V3967 V3968)))) (do (shen.unbindv V3652 V3967) Result))) false))) (if (= Case false) (let V3653 (shen.lazyderef V3965 V3967) (if (= () V3653) (let V3654 (shen.lazyderef V3966 V3967) (if (cons? V3654) (let V3655 (shen.lazyderef (hd V3654) V3967) (if (= list V3655) (let V3656 (shen.lazyderef (tl V3654) V3967) (if (cons? V3656) (let A (hd V3656) (let V3657 (shen.lazyderef (tl V3656) V3967) (if (= () V3657) (do (shen.incinfs) (thaw V3968)) (if (shen.pvar? V3657) (do (shen.bindv V3657 () V3967) (let Result (do (shen.incinfs) (thaw V3968)) (do (shen.unbindv V3657 V3967) Result))) false)))) (if (shen.pvar? V3656) (let A (shen.newpv V3967) (do (shen.bindv V3656 (cons A ()) V3967) (let Result (do (shen.incinfs) (thaw V3968)) (do (shen.unbindv V3656 V3967) Result)))) false))) (if (shen.pvar? V3655) (do (shen.bindv V3655 list V3967) (let Result (let V3658 (shen.lazyderef (tl V3654) V3967) (if (cons? V3658) (let A (hd V3658) (let V3659 (shen.lazyderef (tl V3658) V3967) (if (= () V3659) (do (shen.incinfs) (thaw V3968)) (if (shen.pvar? V3659) (do (shen.bindv V3659 () V3967) (let Result (do (shen.incinfs) (thaw V3968)) (do (shen.unbindv V3659 V3967) Result))) false)))) (if (shen.pvar? V3658) (let A (shen.newpv V3967) (do (shen.bindv V3658 (cons A ()) V3967) (let Result (do (shen.incinfs) (thaw V3968)) (do (shen.unbindv V3658 V3967) Result)))) false))) (do (shen.unbindv V3655 V3967) Result))) false))) (if (shen.pvar? V3654) (let A (shen.newpv V3967) (do (shen.bindv V3654 (cons list (cons A ())) V3967) (let Result (do (shen.incinfs) (thaw V3968)) (do (shen.unbindv V3654 V3967) Result)))) false))) false)) Case)) Case)) Case)) Case)))

(defun shen.by_hypothesis (V3974 V3975 V3976 V3977 V3978) (let Case (let V3640 (shen.lazyderef V3976 V3977) (if (cons? V3640) (let V3641 (shen.lazyderef (hd V3640) V3977) (if (cons? V3641) (let Y (hd V3641) (let V3642 (shen.lazyderef (tl V3641) V3977) (if (cons? V3642) (let V3643 (shen.lazyderef (hd V3642) V3977) (if (= : V3643) (let V3644 (shen.lazyderef (tl V3642) V3977) (if (cons? V3644) (let B (hd V3644) (let V3645 (shen.lazyderef (tl V3644) V3977) (if (= () V3645) (do (shen.incinfs) (identical V3974 Y V3977 (freeze (unify! V3975 B V3977 V3978)))) false))) false)) false)) false))) false)) false)) (if (= Case false) (let V3646 (shen.lazyderef V3976 V3977) (if (cons? V3646) (let Hyp (tl V3646) (do (shen.incinfs) (shen.by_hypothesis V3974 V3975 Hyp V3977 V3978))) false)) Case)))

(defun shen.t*-def (V3984 V3985 V3986 V3987 V3988) (let V3634 (shen.lazyderef V3984 V3987) (if (cons? V3634) (let V3635 (shen.lazyderef (hd V3634) V3987) (if (= define V3635) (let V3636 (shen.lazyderef (tl V3634) V3987) (if (cons? V3636) (let F (hd V3636) (let X (tl V3636) (let Y (shen.newpv V3987) (let E (shen.newpv V3987) (do (shen.incinfs) (shen.t*-defh (compile (lambda Y (shen.<sig+rules> Y)) X (lambda E (if (cons? E) (simple-error (cn "parse error here: " (shen.app E "
" shen.s))) (simple-error "parse error
")))) F V3985 V3986 V3987 V3988)))))) false)) false)) false)))

(defun shen.t*-defh (V3995 V3996 V3997 V3998 V3999 V4000) (let V3630 (shen.lazyderef V3995 V3999) (if (cons? V3630) (let Sig (hd V3630) (let Rules (tl V3630) (do (shen.incinfs) (shen.t*-defhh Sig (shen.ue-sig Sig) V3996 V3997 V3998 Rules V3999 V4000)))) false)))

(defun shen.t*-defhh (V4009 V4010 V4011 V4012 V4013 V4014 V4015 V4016) (do (shen.incinfs) (shen.t*-rules V4014 V4010 1 V4011 (cons (cons V4011 (cons : (cons V4010 ()))) V4013) V4015 (freeze (shen.memo V4011 V4009 V4012 V4015 V4016)))))

(defun shen.memo (V4022 V4023 V4024 V4025 V4026) (let Jnk (shen.newpv V4025) (do (shen.incinfs) (unify! V4024 V4023 V4025 (freeze (bind Jnk (declare (shen.lazyderef V4022 V4025) (shen.lazyderef V4024 V4025)) V4025 V4026))))))

(defun shen.<sig+rules> (V4028) (let Parse_shen.<signature> (shen.<signature> V4028) (if (not (= (fail) Parse_shen.<signature>)) (let Parse_shen.<non-ll-rules> (shen.<non-ll-rules> Parse_shen.<signature>) (if (not (= (fail) Parse_shen.<non-ll-rules>)) (shen.pair (hd Parse_shen.<non-ll-rules>) (cons (shen.hdtl Parse_shen.<signature>) (shen.hdtl Parse_shen.<non-ll-rules>))) (fail))) (fail))))

(defun shen.<non-ll-rules> (V4030) (let YaccParse (let Parse_shen.<rule> (shen.<rule> V4030) (if (not (= (fail) Parse_shen.<rule>)) (let Parse_shen.<non-ll-rules> (shen.<non-ll-rules> Parse_shen.<rule>) (if (not (= (fail) Parse_shen.<non-ll-rules>)) (shen.pair (hd Parse_shen.<non-ll-rules>) (cons (shen.hdtl Parse_shen.<rule>) (shen.hdtl Parse_shen.<non-ll-rules>))) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_shen.<rule> (shen.<rule> V4030) (if (not (= (fail) Parse_shen.<rule>)) (shen.pair (hd Parse_shen.<rule>) (cons (shen.hdtl Parse_shen.<rule>) ())) (fail))) YaccParse)))

(defun shen.ue (V4032) (cond ((and (cons? V4032) (and (cons? (tl V4032)) (and (= () (tl (tl V4032))) (= (hd V4032) protect)))) V4032) ((cons? V4032) (map (lambda Z (shen.ue Z)) V4032)) ((variable? V4032) (concat && V4032)) (true V4032)))

(defun shen.ue-sig (V4034) (cond ((cons? V4034) (map (lambda Z (shen.ue-sig Z)) V4034)) ((variable? V4034) (concat &&& V4034)) (true V4034)))

(defun shen.ues (V4040) (cond ((shen.ue? V4040) (cons V4040 ())) ((cons? V4040) (union (shen.ues (hd V4040)) (shen.ues (tl V4040)))) (true ())))

(defun shen.ue? (V4042) (and (symbol? V4042) (shen.ue-h? (str V4042))))

(defun shen.ue-h? (V4050) (cond ((and (shen.+string? V4050) (and (= "&" (pos V4050 0)) (and (shen.+string? (tlstr V4050)) (= "&" (pos (tlstr V4050) 0))))) true) (true false)))

(defun shen.t*-rules (V4058 V4059 V4060 V4061 V4062 V4063 V4064) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let V3614 (shen.lazyderef V4058 V4063) (if (= () V3614) (do (shen.incinfs) (thaw V4064)) false)) (if (= Case false) (let Case (let V3615 (shen.lazyderef V4058 V4063) (if (cons? V3615) (let Rule (hd V3615) (let Rules (tl V3615) (do (shen.incinfs) (shen.t*-rule (shen.ue Rule) V4059 V4062 V4063 (freeze (cut Throwcontrol V4063 (freeze (shen.t*-rules Rules V4059 (+ V4060 1) V4061 V4062 V4063 V4064)))))))) false)) (if (= Case false) (let Err (shen.newpv V4063) (do (shen.incinfs) (bind Err (simple-error (cn "type error in rule " (shen.app (shen.lazyderef V4060 V4063) (cn " of " (shen.app (shen.lazyderef V4061 V4063) "" shen.a)) shen.a))) V4063 V4064))) Case)) Case)))))

(defun shen.t*-rule (V4070 V4071 V4072 V4073 V4074) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let V3606 (shen.lazyderef V4070 V4073) (if (cons? V3606) (let Patterns (hd V3606) (let V3607 (shen.lazyderef (tl V3606) V4073) (if (cons? V3607) (let Action (hd V3607) (let V3608 (shen.lazyderef (tl V3607) V4073) (if (= () V3608) (let NewHyps (shen.newpv V4073) (do (shen.incinfs) (shen.newhyps (shen.placeholders Patterns) V4072 NewHyps V4073 (freeze (shen.t*-patterns Patterns V4071 NewHyps V4073 (freeze (cut Throwcontrol V4073 (freeze (shen.t*-action (shen.curry (shen.ue Action)) (shen.result-type Patterns V4071) (shen.patthyps Patterns V4071 V4072) V4073 V4074))))))))) false))) false))) false)))))

(defun shen.placeholders (V4080) (cond ((shen.ue? V4080) (cons V4080 ())) ((cons? V4080) (union (shen.placeholders (hd V4080)) (shen.placeholders (tl V4080)))) (true ())))

(defun shen.newhyps (V4086 V4087 V4088 V4089 V4090) (let Case (let V3593 (shen.lazyderef V4086 V4089) (if (= () V3593) (do (shen.incinfs) (unify! V4088 V4087 V4089 V4090)) false)) (if (= Case false) (let V3594 (shen.lazyderef V4086 V4089) (if (cons? V3594) (let V3589 (hd V3594) (let Vs (tl V3594) (let V3595 (shen.lazyderef V4088 V4089) (if (cons? V3595) (let V3596 (shen.lazyderef (hd V3595) V4089) (if (cons? V3596) (let V (hd V3596) (let V3597 (shen.lazyderef (tl V3596) V4089) (if (cons? V3597) (let V3598 (shen.lazyderef (hd V3597) V4089) (if (= : V3598) (let V3599 (shen.lazyderef (tl V3597) V4089) (if (cons? V3599) (let A (hd V3599) (let V3600 (shen.lazyderef (tl V3599) V4089) (if (= () V3600) (let NewHyp (tl V3595) (do (shen.incinfs) (unify! V V3589 V4089 (freeze (shen.newhyps Vs V4087 NewHyp V4089 V4090))))) (if (shen.pvar? V3600) (do (shen.bindv V3600 () V4089) (let Result (let NewHyp (tl V3595) (do (shen.incinfs) (unify! V V3589 V4089 (freeze (shen.newhyps Vs V4087 NewHyp V4089 V4090))))) (do (shen.unbindv V3600 V4089) Result))) false)))) (if (shen.pvar? V3599) (let A (shen.newpv V4089) (do (shen.bindv V3599 (cons A ()) V4089) (let Result (let NewHyp (tl V3595) (do (shen.incinfs) (unify! V V3589 V4089 (freeze (shen.newhyps Vs V4087 NewHyp V4089 V4090))))) (do (shen.unbindv V3599 V4089) Result)))) false))) (if (shen.pvar? V3598) (do (shen.bindv V3598 : V4089) (let Result (let V3601 (shen.lazyderef (tl V3597) V4089) (if (cons? V3601) (let A (hd V3601) (let V3602 (shen.lazyderef (tl V3601) V4089) (if (= () V3602) (let NewHyp (tl V3595) (do (shen.incinfs) (unify! V V3589 V4089 (freeze (shen.newhyps Vs V4087 NewHyp V4089 V4090))))) (if (shen.pvar? V3602) (do (shen.bindv V3602 () V4089) (let Result (let NewHyp (tl V3595) (do (shen.incinfs) (unify! V V3589 V4089 (freeze (shen.newhyps Vs V4087 NewHyp V4089 V4090))))) (do (shen.unbindv V3602 V4089) Result))) false)))) (if (shen.pvar? V3601) (let A (shen.newpv V4089) (do (shen.bindv V3601 (cons A ()) V4089) (let Result (let NewHyp (tl V3595) (do (shen.incinfs) (unify! V V3589 V4089 (freeze (shen.newhyps Vs V4087 NewHyp V4089 V4090))))) (do (shen.unbindv V3601 V4089) Result)))) false))) (do (shen.unbindv V3598 V4089) Result))) false))) (if (shen.pvar? V3597) (let A (shen.newpv V4089) (do (shen.bindv V3597 (cons : (cons A ())) V4089) (let Result (let NewHyp (tl V3595) (do (shen.incinfs) (unify! V V3589 V4089 (freeze (shen.newhyps Vs V4087 NewHyp V4089 V4090))))) (do (shen.unbindv V3597 V4089) Result)))) false)))) (if (shen.pvar? V3596) (let V (shen.newpv V4089) (let A (shen.newpv V4089) (do (shen.bindv V3596 (cons V (cons : (cons A ()))) V4089) (let Result (let NewHyp (tl V3595) (do (shen.incinfs) (unify! V V3589 V4089 (freeze (shen.newhyps Vs V4087 NewHyp V4089 V4090))))) (do (shen.unbindv V3596 V4089) Result))))) false))) (if (shen.pvar? V3595) (let V (shen.newpv V4089) (let A (shen.newpv V4089) (let NewHyp (shen.newpv V4089) (do (shen.bindv V3595 (cons (cons V (cons : (cons A ()))) NewHyp) V4089) (let Result (do (shen.incinfs) (unify! V V3589 V4089 (freeze (shen.newhyps Vs V4087 NewHyp V4089 V4090)))) (do (shen.unbindv V3595 V4089) Result)))))) false))))) false)) Case)))

(defun shen.patthyps (V4096 V4097 V4098) (cond ((= () V4096) V4098) ((and (cons? V4096) (and (cons? V4097) (and (cons? (tl V4097)) (and (= --> (hd (tl V4097))) (and (cons? (tl (tl V4097))) (= () (tl (tl (tl V4097))))))))) (adjoin (cons (shen.curry (hd V4096)) (cons : (cons (hd V4097) ()))) (shen.patthyps (tl V4096) (hd (tl (tl V4097))) V4098))) (true (shen.f_error shen.patthyps))))

(defun shen.result-type (V4105 V4106) (cond ((and (= () V4105) (and (cons? V4106) (and (= --> (hd V4106)) (and (cons? (tl V4106)) (= () (tl (tl V4106))))))) (hd (tl V4106))) ((= () V4105) V4106) ((and (cons? V4105) (and (cons? V4106) (and (cons? (tl V4106)) (and (= --> (hd (tl V4106))) (and (cons? (tl (tl V4106))) (= () (tl (tl (tl V4106))))))))) (shen.result-type (tl V4105) (hd (tl (tl V4106))))) (true (shen.f_error shen.result-type))))

(defun shen.t*-patterns (V4112 V4113 V4114 V4115 V4116) (let Case (let V3581 (shen.lazyderef V4112 V4115) (if (= () V3581) (do (shen.incinfs) (thaw V4116)) false)) (if (= Case false) (let V3582 (shen.lazyderef V4112 V4115) (if (cons? V3582) (let Pattern (hd V3582) (let Patterns (tl V3582) (let V3583 (shen.lazyderef V4113 V4115) (if (cons? V3583) (let A (hd V3583) (let V3584 (shen.lazyderef (tl V3583) V4115) (if (cons? V3584) (let V3585 (shen.lazyderef (hd V3584) V4115) (if (= --> V3585) (let V3586 (shen.lazyderef (tl V3584) V4115) (if (cons? V3586) (let B (hd V3586) (let V3587 (shen.lazyderef (tl V3586) V4115) (if (= () V3587) (do (shen.incinfs) (shen.t* (cons (shen.curry Pattern) (cons : (cons A ()))) V4114 V4115 (freeze (shen.t*-patterns Patterns B V4114 V4115 V4116)))) false))) false)) false)) false))) false)))) false)) Case)))

(defun shen.t*-action (V4122 V4123 V4124 V4125 V4126) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let V3558 (shen.lazyderef V4122 V4125) (if (cons? V3558) (let V3559 (shen.lazyderef (hd V3558) V4125) (if (= where V3559) (let V3560 (shen.lazyderef (tl V3558) V4125) (if (cons? V3560) (let P (hd V3560) (let V3561 (shen.lazyderef (tl V3560) V4125) (if (cons? V3561) (let Action (hd V3561) (let V3562 (shen.lazyderef (tl V3561) V4125) (if (= () V3562) (do (shen.incinfs) (cut Throwcontrol V4125 (freeze (shen.t* (cons P (cons : (cons boolean ()))) V4124 V4125 (freeze (cut Throwcontrol V4125 (freeze (shen.t*-action Action V4123 (cons (cons P (cons : (cons verified ()))) V4124) V4125 V4126)))))))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V3563 (shen.lazyderef V4122 V4125) (if (cons? V3563) (let V3564 (shen.lazyderef (hd V3563) V4125) (if (= shen.choicepoint! V3564) (let V3565 (shen.lazyderef (tl V3563) V4125) (if (cons? V3565) (let V3566 (shen.lazyderef (hd V3565) V4125) (if (cons? V3566) (let V3567 (shen.lazyderef (hd V3566) V4125) (if (cons? V3567) (let V3568 (shen.lazyderef (hd V3567) V4125) (if (= fail-if V3568) (let V3569 (shen.lazyderef (tl V3567) V4125) (if (cons? V3569) (let F (hd V3569) (let V3570 (shen.lazyderef (tl V3569) V4125) (if (= () V3570) (let V3571 (shen.lazyderef (tl V3566) V4125) (if (cons? V3571) (let Action (hd V3571) (let V3572 (shen.lazyderef (tl V3571) V4125) (if (= () V3572) (let V3573 (shen.lazyderef (tl V3565) V4125) (if (= () V3573) (do (shen.incinfs) (cut Throwcontrol V4125 (freeze (shen.t*-action (cons where (cons (cons not (cons (cons F (cons Action ())) ())) (cons Action ()))) V4123 V4124 V4125 V4126)))) false)) false))) false)) false))) false)) false)) false)) false)) false)) false)) false)) (if (= Case false) (let Case (let V3574 (shen.lazyderef V4122 V4125) (if (cons? V3574) (let V3575 (shen.lazyderef (hd V3574) V4125) (if (= shen.choicepoint! V3575) (let V3576 (shen.lazyderef (tl V3574) V4125) (if (cons? V3576) (let Action (hd V3576) (let V3577 (shen.lazyderef (tl V3576) V4125) (if (= () V3577) (do (shen.incinfs) (cut Throwcontrol V4125 (freeze (shen.t*-action (cons where (cons (cons not (cons (cons (cons = (cons Action ())) (cons (cons fail ()) ())) ())) (cons Action ()))) V4123 V4124 V4125 V4126)))) false))) false)) false)) false)) (if (= Case false) (do (shen.incinfs) (shen.t* (cons V4122 (cons : (cons V4123 ()))) V4124 V4125 V4126)) Case)) Case)) Case)))))

(defun findall (V4132 V4133 V4134 V4135 V4136) (let B (shen.newpv V4135) (let A (shen.newpv V4135) (do (shen.incinfs) (bind A (gensym shen.a) V4135 (freeze (bind B (set (shen.lazyderef A V4135) ()) V4135 (freeze (shen.findallhelp V4132 V4133 V4134 A V4135 V4136)))))))))

(defun shen.findallhelp (V4143 V4144 V4145 V4146 V4147 V4148) (let Case (do (shen.incinfs) (call V4144 V4147 (freeze (shen.remember V4146 V4143 V4147 (freeze (fwhen false V4147 V4148)))))) (if (= Case false) (do (shen.incinfs) (bind V4145 (value (shen.lazyderef V4146 V4147)) V4147 V4148)) Case)))

(defun shen.remember (V4153 V4154 V4155 V4156) (let B (shen.newpv V4155) (do (shen.incinfs) (bind B (set (shen.deref V4153 V4155) (cons (shen.deref V4154 V4155) (value (shen.deref V4153 V4155)))) V4155 V4156))))



