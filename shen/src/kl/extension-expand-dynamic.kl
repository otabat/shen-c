"Copyright (c) 2019 Bruno Deferrari.
BSD 3-Clause License: http://opensource.org/licenses/BSD-3-Clause"

(defun shen.x.expand-dynamic.initialise () (do (set shen.x.expand-dynamic.*external-symbols* ()) (set shen.x.expand-dynamic.*arities* ())))

(defun shen.x.expand-dynamic.expand-dynamic (V6271) (cond ((= () V6271) ()) ((and (cons? V6271) (and (cons? (hd V6271)) (and (= declare (hd (hd V6271))) (and (cons? (tl (hd V6271))) (and (cons? (tl (tl (hd V6271)))) (= () (tl (tl (tl (hd V6271)))))))))) (append (shen.x.expand-dynamic.expand-declare (hd V6271)) (shen.x.expand-dynamic.expand-dynamic (tl V6271)))) ((and (cons? V6271) (and (cons? (hd V6271)) (and (= put (hd (hd V6271))) (and (cons? (tl (hd V6271))) (and (cons? (hd (tl (hd V6271)))) (and (= intern (hd (hd (tl (hd V6271))))) (and (cons? (tl (hd (tl (hd V6271))))) (and (= "shen" (hd (tl (hd (tl (hd V6271)))))) (and (= () (tl (tl (hd (tl (hd V6271)))))) (and (cons? (tl (tl (hd V6271)))) (and (= shen.external-symbols (hd (tl (tl (hd V6271))))) (and (cons? (tl (tl (tl (hd V6271))))) (and (cons? (tl (tl (tl (tl (hd V6271)))))) (= () (tl (tl (tl (tl (tl (hd V6271)))))))))))))))))))) (do (set shen.x.expand-dynamic.*external-symbols* (eval-kl (hd (tl (tl (tl (hd V6271))))))) (cons (hd V6271) (shen.x.expand-dynamic.expand-dynamic (tl V6271))))) ((and (cons? V6271) (and (cons? (hd V6271)) (and (= shen.initialise_arity_table (hd (hd V6271))) (and (cons? (tl (hd V6271))) (= () (tl (tl (hd V6271)))))))) (do (set shen.x.expand-dynamic.*arities* (eval-kl (hd (tl (hd V6271))))) (cons (hd V6271) (shen.x.expand-dynamic.expand-dynamic (tl V6271))))) ((and (cons? V6271) (and (cons? (hd V6271)) (and (= shen.for-each (hd (hd V6271))) (and (cons? (tl (hd V6271))) (and (cons? (hd (tl (hd V6271)))) (and (= lambda (hd (hd (tl (hd V6271))))) (and (cons? (tl (hd (tl (hd V6271))))) (and (cons? (tl (tl (hd (tl (hd V6271)))))) (and (cons? (hd (tl (tl (hd (tl (hd V6271))))))) (and (= shen.set-lambda-form-entry (hd (hd (tl (tl (hd (tl (hd V6271)))))))) (and (cons? (tl (hd (tl (tl (hd (tl (hd V6271)))))))) (and (= () (tl (tl (hd (tl (tl (hd (tl (hd V6271))))))))) (and (= () (tl (tl (tl (hd (tl (hd V6271))))))) (and (cons? (tl (tl (hd V6271)))) (and (= () (tl (tl (tl (hd V6271))))) (= (hd (tl (hd (tl (tl (hd (tl (hd V6271)))))))) (hd (tl (hd (tl (hd V6271))))))))))))))))))))) (append (shen.x.expand-dynamic.expand-lambda-entries (hd (tl (tl (hd V6271))))) (shen.x.expand-dynamic.expand-dynamic (tl V6271)))) ((cons? V6271) (cons (hd V6271) (shen.x.expand-dynamic.expand-dynamic (tl V6271)))) (true (shen.f_error shen.x.expand-dynamic.expand-dynamic))))

(defun shen.x.expand-dynamic.expand-declare (V6273) (cond ((and (cons? V6273) (and (= declare (hd V6273)) (and (cons? (tl V6273)) (and (cons? (tl (tl V6273))) (= () (tl (tl (tl V6273)))))))) (let Eval (eval-kl V6273) (let F* (concat shen.type-signature-of- (hd (tl V6273))) (let KlDef (ps F*) (let RecordSig (cons set (cons shen.*signedfuncs* (cons (cons cons (cons (cons cons (tl V6273)) (cons (cons value (cons shen.*signedfuncs* ())) ()))) ()))) (let RecordLambda (cons shen.set-lambda-form-entry (cons (cons cons (cons F* (cons (shen.lambda-form F* 3) ()))) ())) (cons KlDef (cons RecordSig (cons RecordLambda ()))))))))) (true (shen.f_error shen.x.expand-dynamic.expand-declare))))

(defun shen.x.expand-dynamic.expand-lambda-entries (V6276) (cond ((= () V6276) ()) ((and (cons? V6276) (and (= mapcan (hd V6276)) (and (cons? (tl V6276)) (and (cons? (hd (tl V6276))) (and (= lambda (hd (hd (tl V6276)))) (and (cons? (tl (hd (tl V6276)))) (and (cons? (tl (tl (hd (tl V6276))))) (and (cons? (hd (tl (tl (hd (tl V6276)))))) (and (= shen.lambda-form-entry (hd (hd (tl (tl (hd (tl V6276))))))) (and (cons? (tl (hd (tl (tl (hd (tl V6276))))))) (and (= () (tl (tl (hd (tl (tl (hd (tl V6276)))))))) (and (= () (tl (tl (tl (hd (tl V6276)))))) (and (cons? (tl (tl V6276))) (and (cons? (hd (tl (tl V6276)))) (and (= external (hd (hd (tl (tl V6276))))) (and (cons? (tl (hd (tl (tl V6276))))) (and (cons? (hd (tl (hd (tl (tl V6276)))))) (and (= intern (hd (hd (tl (hd (tl (tl V6276))))))) (and (cons? (tl (hd (tl (hd (tl (tl V6276))))))) (and (= "shen" (hd (tl (hd (tl (hd (tl (tl V6276)))))))) (and (= () (tl (tl (hd (tl (hd (tl (tl V6276)))))))) (and (= () (tl (tl (hd (tl (tl V6276)))))) (and (= () (tl (tl (tl V6276)))) (= (hd (tl (hd (tl (tl (hd (tl V6276))))))) (hd (tl (hd (tl V6276)))))))))))))))))))))))))))) (mapcan (lambda F (shen.x.expand-dynamic.expand-lambda-form-entry F)) (value shen.x.expand-dynamic.*external-symbols*))) ((and (cons? V6276) (and (= cons (hd V6276)) (and (cons? (tl V6276)) (and (cons? (hd (tl V6276))) (and (= cons (hd (hd (tl V6276)))) (and (cons? (tl (hd (tl V6276)))) (and (cons? (tl (tl (hd (tl V6276))))) (and (= () (tl (tl (tl (hd (tl V6276)))))) (and (cons? (tl (tl V6276))) (= () (tl (tl (tl V6276))))))))))))) (cons (cons shen.set-lambda-form-entry (cons (hd (tl V6276)) ())) (shen.x.expand-dynamic.expand-lambda-entries (hd (tl (tl V6276)))))) (true (shen.f_error shen.x.expand-dynamic.expand-lambda-entries))))

(defun shen.x.expand-dynamic.get-arity (V6288 V6289) (cond ((= () V6289) -1) ((and (cons? V6289) (and (cons? (tl V6289)) (= (hd V6289) V6288))) (hd (tl V6289))) ((and (cons? V6289) (cons? (tl V6289))) (shen.x.expand-dynamic.get-arity V6288 (tl (tl V6289)))) (true (shen.f_error shen.x.expand-dynamic.get-arity))))

(defun shen.x.expand-dynamic.expand-lambda-form-entry (V6291) (cond ((= package V6291) ()) ((= receive V6291) ()) (true (let ArityF (shen.x.expand-dynamic.get-arity V6291 (value shen.x.expand-dynamic.*arities*)) (if (= ArityF -1) () (if (= ArityF 0) () (cons (cons shen.set-lambda-form-entry (cons (cons cons (cons V6291 (cons (shen.lambda-form V6291 ArityF) ()))) ())) ())))))))

(defun shen.x.expand-dynamic.split-defuns-h (V6294 V6295) (cond ((and (cons? V6294) (and (cons? (hd V6294)) (and (= defun (hd (hd V6294))) (tuple? V6295)))) (shen.x.expand-dynamic.split-defuns-h (tl V6294) (@p (cons (hd V6294) (fst V6295)) (snd V6295)))) ((and (cons? V6294) (tuple? V6295)) (shen.x.expand-dynamic.split-defuns-h (tl V6294) (@p (fst V6295) (cons (hd V6294) (snd V6295))))) ((and (= () V6294) (tuple? V6295)) (@p (reverse (fst V6295)) (reverse (snd V6295)))) (true (shen.f_error shen.x.expand-dynamic.split-defuns-h))))

(defun shen.x.expand-dynamic.split-defuns (V6297) (shen.x.expand-dynamic.split-defuns-h V6297 (@p () ())))

(defun shen.x.expand-dynamic.wrap-in-defun (V6301 V6302 V6303) (cons defun (cons V6301 (cons V6302 (cons (shen.x.expand-dynamic.to-single-expression V6303) ())))))

(defun shen.x.expand-dynamic.to-single-expression (V6305) (cond ((and (cons? V6305) (= () (tl V6305))) (hd V6305)) ((cons? V6305) (cons do (cons (hd V6305) (cons (shen.x.expand-dynamic.to-single-expression (tl V6305)) ())))) (true (shen.f_error shen.x.expand-dynamic.to-single-expression))))



