"Copyright (c) 2012-2019 Bruno Deferrari.  All rights reserved.
BSD 3-Clause License: http://opensource.org/licenses/BSD-3-Clause"

(defun shen.x.factorise-defun.factorise-defun (V6067) (cond ((and (cons? V6067) (and (= defun (hd V6067)) (and (cons? (tl V6067)) (and (cons? (tl (tl V6067))) (and (cons? (tl (tl (tl V6067)))) (and (cons? (hd (tl (tl (tl V6067))))) (and (= cond (hd (hd (tl (tl (tl V6067)))))) (= () (tl (tl (tl (tl V6067)))))))))))) (cons defun (cons (hd (tl V6067)) (cons (hd (tl (tl V6067))) (cons (shen.x.factorise-defun.factorise-cond (hd (tl (tl (tl V6067)))) (cons shen.f_error (cons (hd (tl V6067)) ())) (hd (tl (tl V6067)))) ()))))) (true V6067)))

(defun shen.x.factorise-defun.factorise-cond (V6079 V6080 V6081) (cond ((and (cons? V6079) (= cond (hd V6079))) (shen.x.factorise-defun.inline-mono-labels (shen.x.factorise-defun.rebranch (shen.x.factorise-defun.add-returns (tl V6079)) V6080) V6081)) (true V6079)))

(defun shen.x.factorise-defun.add-returns (V6083) (cond ((= () V6083) ()) ((and (cons? V6083) (and (cons? (hd V6083)) (and (cons? (tl (hd V6083))) (= () (tl (tl (hd V6083))))))) (cons (cons (hd (hd V6083)) (cons (cons %%return (tl (hd V6083))) ())) (shen.x.factorise-defun.add-returns (tl V6083)))) (true (shen.f_error shen.x.factorise-defun.add-returns))))

(defun shen.x.factorise-defun.generate-label () (gensym %%label))

(defun shen.x.factorise-defun.free-variables (V6086 V6087) (reverse (shen.x.factorise-defun.free-variables-h V6086 V6087 ())))

(defun shen.x.factorise-defun.free-variables-h (V6099 V6100 V6101) (cond ((and (cons? V6099) (and (= let (hd V6099)) (and (cons? (tl V6099)) (and (cons? (tl (tl V6099))) (and (cons? (tl (tl (tl V6099)))) (= () (tl (tl (tl (tl V6099)))))))))) (shen.x.factorise-defun.free-variables-h (hd (tl (tl (tl V6099)))) (remove (hd (tl V6099)) V6100) (shen.x.factorise-defun.free-variables-h (hd (tl (tl V6099))) V6100 V6101))) ((and (cons? V6099) (and (= lambda (hd V6099)) (and (cons? (tl V6099)) (and (cons? (tl (tl V6099))) (= () (tl (tl (tl V6099)))))))) (shen.x.factorise-defun.free-variables-h (hd (tl (tl V6099))) (remove (hd (tl V6099)) V6100) V6101)) ((cons? V6099) (shen.x.factorise-defun.free-variables-h (tl V6099) V6100 (shen.x.factorise-defun.free-variables-h (hd V6099) V6100 V6101))) ((element? V6099 V6100) (adjoin V6099 V6101)) (true V6101)))

(defun shen.x.factorise-defun.attach-free-variables (V6104 V6105) (cond ((and (cons? V6104) (and (= %%let-label (hd V6104)) (and (cons? (tl V6104)) (and (cons? (tl (tl V6104))) (and (cons? (tl (tl (tl V6104)))) (= () (tl (tl (tl (tl V6104)))))))))) (let FreeVars (shen.x.factorise-defun.free-variables (hd (tl (tl V6104))) V6105) (let NewBody (if (= () FreeVars) (hd (tl (tl (tl V6104)))) (subst (cons %%goto-label (cons (hd (tl V6104)) FreeVars)) (cons %%goto-label (cons (hd (tl V6104)) ())) (hd (tl (tl (tl V6104)))))) (cons %%let-label (cons (cons (hd (tl V6104)) FreeVars) (cons (hd (tl (tl V6104))) (cons (shen.x.factorise-defun.inline-mono-labels NewBody V6105) ()))))))) (true (shen.f_error shen.x.factorise-defun.attach-free-variables))))

(defun shen.x.factorise-defun.inline-mono-labels (V6112 V6113) (cond ((and (cons? V6112) (and (= %%let-label (hd V6112)) (and (cons? (tl V6112)) (and (cons? (tl (tl V6112))) (and (cons? (tl (tl (tl V6112)))) (and (= () (tl (tl (tl (tl V6112))))) (> (occurrences (cons %%goto-label (cons (hd (tl V6112)) ())) (hd (tl (tl (tl V6112))))) 1))))))) (shen.x.factorise-defun.attach-free-variables (cons %%let-label (cons (hd (tl V6112)) (cons (shen.x.factorise-defun.inline-mono-labels (hd (tl (tl V6112))) V6113) (tl (tl (tl V6112)))))) V6113)) ((and (cons? V6112) (and (= %%let-label (hd V6112)) (and (cons? (tl V6112)) (and (cons? (tl (tl V6112))) (and (cons? (tl (tl (tl V6112)))) (= () (tl (tl (tl (tl V6112)))))))))) (subst (shen.x.factorise-defun.inline-mono-labels (hd (tl (tl V6112))) V6113) (cons %%goto-label (cons (hd (tl V6112)) ())) (shen.x.factorise-defun.inline-mono-labels (hd (tl (tl (tl V6112)))) V6113))) ((and (cons? V6112) (and (= if (hd V6112)) (and (cons? (tl V6112)) (and (cons? (tl (tl V6112))) (and (cons? (tl (tl (tl V6112)))) (= () (tl (tl (tl (tl V6112)))))))))) (cons if (cons (hd (tl V6112)) (cons (shen.x.factorise-defun.inline-mono-labels (hd (tl (tl V6112))) V6113) (cons (shen.x.factorise-defun.inline-mono-labels (hd (tl (tl (tl V6112)))) V6113) ()))))) ((and (cons? V6112) (and (= let (hd V6112)) (and (cons? (tl V6112)) (and (cons? (tl (tl V6112))) (and (cons? (tl (tl (tl V6112)))) (= () (tl (tl (tl (tl V6112)))))))))) (cons let (cons (hd (tl V6112)) (cons (hd (tl (tl V6112))) (cons (shen.x.factorise-defun.inline-mono-labels (hd (tl (tl (tl V6112)))) (cons (hd (tl V6112)) V6113)) ()))))) (true V6112)))

(defun shen.x.factorise-defun.rebranch (V6120 V6121) (cond ((= () V6120) V6121) ((and (cons? V6120) (and (cons? (hd V6120)) (and (= true (hd (hd V6120))) (and (cons? (tl (hd V6120))) (= () (tl (tl (hd V6120)))))))) (hd (tl (hd V6120)))) ((and (cons? V6120) (and (cons? (hd V6120)) (and (cons? (hd (hd V6120))) (and (= and (hd (hd (hd V6120)))) (and (cons? (tl (hd (hd V6120)))) (and (cons? (tl (tl (hd (hd V6120))))) (and (= () (tl (tl (tl (hd (hd V6120)))))) (and (cons? (tl (hd V6120))) (= () (tl (tl (hd V6120)))))))))))) (let TrueBranch (shen.x.factorise-defun.true-branch (hd (tl (hd (hd V6120)))) V6120) (let FalseBranch (shen.x.factorise-defun.false-branch (hd (tl (hd (hd V6120)))) V6120) (shen.x.factorise-defun.rebranch-h (hd (tl (hd (hd V6120)))) TrueBranch FalseBranch V6121)))) ((and (cons? V6120) (and (cons? (hd V6120)) (and (cons? (tl (hd V6120))) (= () (tl (tl (hd V6120))))))) (let TrueBranch (shen.x.factorise-defun.true-branch (hd (hd V6120)) V6120) (let FalseBranch (shen.x.factorise-defun.false-branch (hd (hd V6120)) V6120) (shen.x.factorise-defun.rebranch-h (hd (hd V6120)) TrueBranch FalseBranch V6121)))) (true (shen.f_error shen.x.factorise-defun.rebranch))))

(defun shen.x.factorise-defun.rebranch-h (V6126 V6127 V6128 V6129) (let NewElse (shen.x.factorise-defun.rebranch V6128 V6129) (shen.x.factorise-defun.with-labelled-else NewElse (lambda GotoElse (shen.x.factorise-defun.merge-same-else-ifs (cons if (cons V6126 (cons (shen.x.factorise-defun.optimize-selectors V6126 (shen.x.factorise-defun.rebranch V6127 GotoElse)) (cons GotoElse ())))))))))

(defun shen.x.factorise-defun.true-branch (V6142 V6143) (cond ((and (cons? V6143) (and (cons? (hd V6143)) (and (cons? (hd (hd V6143))) (and (= and (hd (hd (hd V6143)))) (and (cons? (tl (hd (hd V6143)))) (and (cons? (tl (tl (hd (hd V6143))))) (and (= () (tl (tl (tl (hd (hd V6143)))))) (and (cons? (tl (hd V6143))) (and (= () (tl (tl (hd V6143)))) (= (hd (tl (hd (hd V6143)))) V6142)))))))))) (cons (cons (hd (tl (tl (hd (hd V6143))))) (tl (hd V6143))) (shen.x.factorise-defun.true-branch (hd (tl (hd (hd V6143)))) (tl V6143)))) ((and (cons? V6143) (and (cons? (hd V6143)) (and (cons? (tl (hd V6143))) (and (= () (tl (tl (hd V6143)))) (= (hd (hd V6143)) V6142))))) (cons (cons true (tl (hd V6143))) ())) (true ())))

(defun shen.x.factorise-defun.false-branch (V6152 V6153) (cond ((and (cons? V6153) (and (cons? (hd V6153)) (and (cons? (hd (hd V6153))) (and (= and (hd (hd (hd V6153)))) (and (cons? (tl (hd (hd V6153)))) (and (cons? (tl (tl (hd (hd V6153))))) (and (= () (tl (tl (tl (hd (hd V6153)))))) (and (cons? (tl (hd V6153))) (and (= () (tl (tl (hd V6153)))) (= (hd (tl (hd (hd V6153)))) V6152)))))))))) (shen.x.factorise-defun.false-branch (hd (tl (hd (hd V6153)))) (tl V6153))) ((and (cons? V6153) (and (cons? (hd V6153)) (and (cons? (tl (hd V6153))) (and (= () (tl (tl (hd V6153)))) (= (hd (hd V6153)) V6152))))) (shen.x.factorise-defun.false-branch (hd (hd V6153)) (tl V6153))) (true V6153)))

(defun shen.x.factorise-defun.with-labelled-else (V6156 V6157) (cond ((and (cons? V6156) (and (= %%return (hd V6156)) (and (cons? (tl V6156)) (and (= () (tl (tl V6156))) (not (cons? (hd (tl V6156)))))))) (V6157 V6156)) ((and (cons? V6156) (and (= fail (hd V6156)) (= () (tl V6156)))) (V6157 V6156)) ((and (cons? V6156) (and (= %%goto-label (hd V6156)) (and (cons? (tl V6156)) (= () (tl (tl V6156)))))) (V6157 V6156)) (true (let Label (shen.x.factorise-defun.generate-label) (cons %%let-label (cons Label (cons V6156 (cons (V6157 (cons %%goto-label (cons Label ()))) ()))))))))

(defun shen.x.factorise-defun.merge-same-else-ifs (V6160) (cond ((and (cons? V6160) (and (= if (hd V6160)) (and (cons? (tl V6160)) (and (cons? (tl (tl V6160))) (and (cons? (hd (tl (tl V6160)))) (and (= if (hd (hd (tl (tl V6160))))) (and (cons? (tl (hd (tl (tl V6160))))) (and (cons? (tl (tl (hd (tl (tl V6160)))))) (and (cons? (tl (tl (tl (hd (tl (tl V6160))))))) (and (= () (tl (tl (tl (tl (hd (tl (tl V6160)))))))) (and (cons? (tl (tl (tl V6160)))) (and (= () (tl (tl (tl (tl V6160))))) (= (hd (tl (tl (tl V6160)))) (hd (tl (tl (tl (hd (tl (tl V6160)))))))))))))))))))) (cons if (cons (cons and (cons (hd (tl V6160)) (cons (hd (tl (hd (tl (tl V6160))))) ()))) (cons (hd (tl (tl (hd (tl (tl V6160)))))) (tl (tl (tl V6160))))))) (true V6160)))

(defun shen.x.factorise-defun.concat/ (V6163 V6164) (concat V6163 (concat / V6164)))

(defun shen.x.factorise-defun.exp-var (V6168) (cond ((and (cons? V6168) (and (cons? (tl V6168)) (and (= () (tl (tl V6168))) (symbol? (hd V6168))))) (shen.x.factorise-defun.concat/ (shen.x.factorise-defun.exp-var (hd (tl V6168))) (hd V6168))) ((cons? V6168) (gensym (hd V6168))) (true V6168)))

(defun shen.x.factorise-defun.optimize-selectors (V6171 V6172) (shen.x.factorise-defun.bind-repeating-selectors (shen.x.factorise-defun.test->selectors V6171) V6172))

(defun shen.x.factorise-defun.test->selectors (V6178) (cond ((and (cons? V6178) (and (= cons? (hd V6178)) (and (cons? (tl V6178)) (= () (tl (tl V6178)))))) (cons (cons hd (tl V6178)) (cons (cons tl (tl V6178)) ()))) ((and (cons? V6178) (and (= tuple? (hd V6178)) (and (cons? (tl V6178)) (= () (tl (tl V6178)))))) (cons (cons fst (tl V6178)) (cons (cons snd (tl V6178)) ()))) ((and (cons? V6178) (and (= shen.+string? (hd V6178)) (and (cons? (tl V6178)) (= () (tl (tl V6178)))))) (cons (cons hdstr (tl V6178)) (cons (cons tlstr (tl V6178)) ()))) ((and (cons? V6178) (and (= shen.+vector? (hd V6178)) (and (cons? (tl V6178)) (= () (tl (tl V6178)))))) (cons (cons hdv (tl V6178)) (cons (cons tlv (tl V6178)) ()))) (true (let Result (shen.x.factorise-defun.apply-selector-handlers (value shen.x.factorise-defun.*selector-handlers*) V6178) (if (= Result (fail)) () Result)))))

(defun shen.x.factorise-defun.bind-repeating-selectors (V6181 V6182) (cond ((cons? V6181) (shen.x.factorise-defun.bind-selector (hd V6181) (shen.x.factorise-defun.bind-repeating-selectors (tl V6181) V6182))) ((= () V6181) V6182) (true (shen.f_error shen.x.factorise-defun.bind-repeating-selectors))))

(defun shen.x.factorise-defun.bind-selector (V6189 V6190) (cond ((> (occurrences V6189 V6190) 1) (let Var (shen.x.factorise-defun.exp-var V6189) (cons let (cons Var (cons V6189 (cons (subst Var V6189 V6190) ())))))) (true V6190)))

(defun shen.x.factorise-defun.apply-selector-handlers (V6203 V6204) (cond ((= () V6203) (fail)) (true (let Freeze (freeze (cond ((cons? V6203) (shen.x.factorise-defun.apply-selector-handlers (tl V6203) V6204)) (true (shen.f_error shen.x.factorise-defun.apply-selector-handlers)))) (if (cons? V6203) (let Result ((hd V6203) V6204) (if (= Result (fail)) (thaw Freeze) Result)) (thaw Freeze))))))

(defun shen.x.factorise-defun.initialise () (do (set shen.x.factorise-defun.*selector-handlers* ()) (do (set shen.x.factorise-defun.*selector-handlers-reg* ()) shen.x.factorise-defun.done)))

(defun shen.x.factorise-defun.register-selector-handler (V6206) (cond ((element? V6206 (value shen.x.factorise-defun.*selector-handlers*)) V6206) (true (do (set shen.x.factorise-defun.*selector-handlers-reg* (cons V6206 (value shen.x.factorise-defun.*selector-handlers*))) (do (set shen.x.factorise-defun.*selector-handlers* (cons (function V6206) (value shen.x.factorise-defun.*selector-handlers*))) V6206)))))

(defun shen.x.factorise-defun.findpos (V6209 V6210) (trap-error (shen.findpos V6209 V6210) (lambda _ (simple-error (shen.app V6209 " is not a selector handler
" shen.a)))))

(defun shen.x.factorise-defun.unregister-selector-handler (V6212) (let Reg (value shen.x.factorise-defun.*selector-handlers-reg*) (let Pos (shen.x.factorise-defun.findpos V6212 Reg) (let RemoveReg (set shen.x.factorise-defun.*selector-handlers-reg* (remove V6212 Reg)) (let RemoveFun (set shen.x.factorise-defun.*selector-handlers* (shen.remove-nth Pos (value shen.x.factorise-defun.*selector-handlers*))) V6212)))))



