"Copyright (c) 2010-2015, Mark Tarver

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice,
this list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation
and/or other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its contributors
may be used to endorse or promote products derived from this software without
specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ''AS IS'' AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
"

(defun shen.shen->kl (V1288 V1289) (compile (lambda X (shen.<define> X)) (cons V1288 V1289) (lambda X (shen.shen-syntax-error V1288 X))))

(defun shen.shen-syntax-error (V1296 V1297) (cond ((cons? V1297) (simple-error (cn "syntax error in " (shen.app V1296 (cn " here:

 " (shen.app (shen.next-50 50 (hd V1297)) "
" shen.a)) shen.a)))) (true (simple-error (cn "syntax error in " (shen.app V1296 "
" shen.a))))))

(defun shen.<define> (V1299) (let YaccParse (let Parse_shen.<name> (shen.<name> V1299) (if (not (= (fail) Parse_shen.<name>)) (let Parse_shen.<signature> (shen.<signature> Parse_shen.<name>) (if (not (= (fail) Parse_shen.<signature>)) (let Parse_shen.<rules> (shen.<rules> Parse_shen.<signature>) (if (not (= (fail) Parse_shen.<rules>)) (shen.pair (hd Parse_shen.<rules>) (shen.compile_to_machine_code (shen.hdtl Parse_shen.<name>) (shen.hdtl Parse_shen.<rules>))) (fail))) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_shen.<name> (shen.<name> V1299) (if (not (= (fail) Parse_shen.<name>)) (let Parse_shen.<rules> (shen.<rules> Parse_shen.<name>) (if (not (= (fail) Parse_shen.<rules>)) (shen.pair (hd Parse_shen.<rules>) (shen.compile_to_machine_code (shen.hdtl Parse_shen.<name>) (shen.hdtl Parse_shen.<rules>))) (fail))) (fail))) YaccParse)))

(defun shen.<name> (V1301) (if (cons? (hd V1301)) (let Parse_X (shen.hdhd V1301) (shen.pair (hd (shen.pair (shen.tlhd V1301) (shen.hdtl V1301))) (if (and (symbol? Parse_X) (not (shen.sysfunc? Parse_X))) Parse_X (simple-error (shen.app Parse_X " is not a legitimate function name.
" shen.a))))) (fail)))

(defun shen.sysfunc? (V1303) (element? V1303 (get (intern "shen") shen.external-symbols (value *property-vector*))))

(defun shen.<signature> (V1307) (if (and (cons? (hd V1307)) (= { (shen.hdhd V1307))) (let NewStream1304 (shen.pair (shen.tlhd V1307) (shen.hdtl V1307)) (let Parse_shen.<signature-help> (shen.<signature-help> NewStream1304) (if (not (= (fail) Parse_shen.<signature-help>)) (if (and (cons? (hd Parse_shen.<signature-help>)) (= } (shen.hdhd Parse_shen.<signature-help>))) (let NewStream1305 (shen.pair (shen.tlhd Parse_shen.<signature-help>) (shen.hdtl Parse_shen.<signature-help>)) (shen.pair (hd NewStream1305) (shen.demodulate (shen.curry-type (shen.hdtl Parse_shen.<signature-help>))))) (fail)) (fail)))) (fail)))

(defun shen.curry-type (V1309) (shen.active-cons (shen.curry-type-h V1309)))

(defun shen.active-cons (V1311) (cond ((and (cons? V1311) (and (cons? (tl V1311)) (and (cons? (tl (tl V1311))) (and (= () (tl (tl (tl V1311)))) (= (hd (tl V1311)) bar!))))) (cons (shen.active-cons (hd V1311)) (shen.active-cons (hd (tl (tl V1311)))))) ((cons? V1311) (cons (shen.active-cons (hd V1311)) (shen.active-cons (tl V1311)))) (true V1311)))

(defun shen.curry-type-h (V1313) (cond ((and (cons? V1313) (and (cons? (tl V1313)) (and (= --> (hd (tl V1313))) (and (cons? (tl (tl V1313))) (and (cons? (tl (tl (tl V1313)))) (= --> (hd (tl (tl (tl V1313)))))))))) (shen.curry-type-h (cons (hd V1313) (cons --> (cons (tl (tl V1313)) ()))))) ((and (cons? V1313) (and (cons? (tl V1313)) (and (= * (hd (tl V1313))) (and (cons? (tl (tl V1313))) (and (cons? (tl (tl (tl V1313)))) (= * (hd (tl (tl (tl V1313)))))))))) (shen.curry-type-h (cons (hd V1313) (cons * (cons (tl (tl V1313)) ()))))) ((cons? V1313) (map (lambda Z (shen.curry-type-h Z)) V1313)) (true V1313)))

(defun shen.<signature-help> (V1315) (let YaccParse (if (cons? (hd V1315)) (let Parse_X (shen.hdhd V1315) (let Parse_shen.<signature-help> (shen.<signature-help> (shen.pair (shen.tlhd V1315) (shen.hdtl V1315))) (if (not (= (fail) Parse_shen.<signature-help>)) (if (not (element? Parse_X (cons { (cons } ())))) (shen.pair (hd Parse_shen.<signature-help>) (cons Parse_X (shen.hdtl Parse_shen.<signature-help>))) (fail)) (fail)))) (fail)) (if (= YaccParse (fail)) (let Parse_<e> (<e> V1315) (if (not (= (fail) Parse_<e>)) (shen.pair (hd Parse_<e>) ()) (fail))) YaccParse)))

(defun shen.<rules> (V1317) (let YaccParse (let Parse_shen.<rule> (shen.<rule> V1317) (if (not (= (fail) Parse_shen.<rule>)) (let Parse_shen.<rules> (shen.<rules> Parse_shen.<rule>) (if (not (= (fail) Parse_shen.<rules>)) (shen.pair (hd Parse_shen.<rules>) (cons (shen.linearise (shen.hdtl Parse_shen.<rule>)) (shen.hdtl Parse_shen.<rules>))) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_shen.<rule> (shen.<rule> V1317) (if (not (= (fail) Parse_shen.<rule>)) (shen.pair (hd Parse_shen.<rule>) (cons (shen.linearise (shen.hdtl Parse_shen.<rule>)) ())) (fail))) YaccParse)))

(defun shen.<rule> (V1325) (let YaccParse (let Parse_shen.<patterns> (shen.<patterns> V1325) (if (not (= (fail) Parse_shen.<patterns>)) (if (and (cons? (hd Parse_shen.<patterns>)) (= -> (shen.hdhd Parse_shen.<patterns>))) (let NewStream1318 (shen.pair (shen.tlhd Parse_shen.<patterns>) (shen.hdtl Parse_shen.<patterns>)) (let Parse_shen.<action> (shen.<action> NewStream1318) (if (not (= (fail) Parse_shen.<action>)) (if (and (cons? (hd Parse_shen.<action>)) (= where (shen.hdhd Parse_shen.<action>))) (let NewStream1319 (shen.pair (shen.tlhd Parse_shen.<action>) (shen.hdtl Parse_shen.<action>)) (let Parse_shen.<guard> (shen.<guard> NewStream1319) (if (not (= (fail) Parse_shen.<guard>)) (shen.pair (hd Parse_shen.<guard>) (cons (shen.hdtl Parse_shen.<patterns>) (cons (cons where (cons (shen.hdtl Parse_shen.<guard>) (cons (shen.hdtl Parse_shen.<action>) ()))) ()))) (fail)))) (fail)) (fail)))) (fail)) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<patterns> (shen.<patterns> V1325) (if (not (= (fail) Parse_shen.<patterns>)) (if (and (cons? (hd Parse_shen.<patterns>)) (= -> (shen.hdhd Parse_shen.<patterns>))) (let NewStream1320 (shen.pair (shen.tlhd Parse_shen.<patterns>) (shen.hdtl Parse_shen.<patterns>)) (let Parse_shen.<action> (shen.<action> NewStream1320) (if (not (= (fail) Parse_shen.<action>)) (shen.pair (hd Parse_shen.<action>) (cons (shen.hdtl Parse_shen.<patterns>) (cons (shen.hdtl Parse_shen.<action>) ()))) (fail)))) (fail)) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<patterns> (shen.<patterns> V1325) (if (not (= (fail) Parse_shen.<patterns>)) (if (and (cons? (hd Parse_shen.<patterns>)) (= <- (shen.hdhd Parse_shen.<patterns>))) (let NewStream1321 (shen.pair (shen.tlhd Parse_shen.<patterns>) (shen.hdtl Parse_shen.<patterns>)) (let Parse_shen.<action> (shen.<action> NewStream1321) (if (not (= (fail) Parse_shen.<action>)) (if (and (cons? (hd Parse_shen.<action>)) (= where (shen.hdhd Parse_shen.<action>))) (let NewStream1322 (shen.pair (shen.tlhd Parse_shen.<action>) (shen.hdtl Parse_shen.<action>)) (let Parse_shen.<guard> (shen.<guard> NewStream1322) (if (not (= (fail) Parse_shen.<guard>)) (shen.pair (hd Parse_shen.<guard>) (cons (shen.hdtl Parse_shen.<patterns>) (cons (cons where (cons (shen.hdtl Parse_shen.<guard>) (cons (cons shen.choicepoint! (cons (shen.hdtl Parse_shen.<action>) ())) ()))) ()))) (fail)))) (fail)) (fail)))) (fail)) (fail))) (if (= YaccParse (fail)) (let Parse_shen.<patterns> (shen.<patterns> V1325) (if (not (= (fail) Parse_shen.<patterns>)) (if (and (cons? (hd Parse_shen.<patterns>)) (= <- (shen.hdhd Parse_shen.<patterns>))) (let NewStream1323 (shen.pair (shen.tlhd Parse_shen.<patterns>) (shen.hdtl Parse_shen.<patterns>)) (let Parse_shen.<action> (shen.<action> NewStream1323) (if (not (= (fail) Parse_shen.<action>)) (shen.pair (hd Parse_shen.<action>) (cons (shen.hdtl Parse_shen.<patterns>) (cons (cons shen.choicepoint! (cons (shen.hdtl Parse_shen.<action>) ())) ()))) (fail)))) (fail)) (fail))) YaccParse)) YaccParse)) YaccParse)))

(defun shen.fail_if (V1328 V1329) (if (V1328 V1329) (fail) V1329))

(defun shen.succeeds? (V1335) (cond ((= V1335 (fail)) false) (true true)))

(defun shen.custom-pattern-compiler (V1338 V1339) ((value shen.*custom-pattern-compiler*) V1338 V1339))

(defun shen.custom-pattern-reducer (V1341) ((value shen.*custom-pattern-reducer*) V1341))

(defun shen.<patterns> (V1343) (let YaccParse (let Parse_shen.<pattern> (shen.<pattern> V1343) (if (not (= (fail) Parse_shen.<pattern>)) (let Parse_shen.<patterns> (shen.<patterns> Parse_shen.<pattern>) (if (not (= (fail) Parse_shen.<patterns>)) (shen.pair (hd Parse_shen.<patterns>) (cons (shen.hdtl Parse_shen.<pattern>) (shen.hdtl Parse_shen.<patterns>))) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_<e> (<e> V1343) (if (not (= (fail) Parse_<e>)) (shen.pair (hd Parse_<e>) ()) (fail))) YaccParse)))

(defun shen.<pattern> (V1356) (let YaccParse (if (and (cons? (hd V1356)) (cons? (shen.hdhd V1356))) (if (and (cons? (hd (shen.pair (shen.hdhd V1356) (shen.hdtl V1356)))) (= @p (shen.hdhd (shen.pair (shen.hdhd V1356) (shen.hdtl V1356))))) (let NewStream1345 (shen.pair (shen.tlhd (shen.pair (shen.hdhd V1356) (shen.hdtl V1356))) (shen.hdtl (shen.pair (shen.hdhd V1356) (shen.hdtl V1356)))) (let Parse_shen.<pattern1> (shen.<pattern1> NewStream1345) (if (not (= (fail) Parse_shen.<pattern1>)) (let Parse_shen.<pattern2> (shen.<pattern2> Parse_shen.<pattern1>) (if (not (= (fail) Parse_shen.<pattern2>)) (shen.pair (hd (shen.pair (shen.tlhd V1356) (shen.hdtl V1356))) (cons @p (cons (shen.hdtl Parse_shen.<pattern1>) (cons (shen.hdtl Parse_shen.<pattern2>) ())))) (fail))) (fail)))) (fail)) (fail)) (if (= YaccParse (fail)) (let YaccParse (if (and (cons? (hd V1356)) (cons? (shen.hdhd V1356))) (if (and (cons? (hd (shen.pair (shen.hdhd V1356) (shen.hdtl V1356)))) (= cons (shen.hdhd (shen.pair (shen.hdhd V1356) (shen.hdtl V1356))))) (let NewStream1347 (shen.pair (shen.tlhd (shen.pair (shen.hdhd V1356) (shen.hdtl V1356))) (shen.hdtl (shen.pair (shen.hdhd V1356) (shen.hdtl V1356)))) (let Parse_shen.<pattern1> (shen.<pattern1> NewStream1347) (if (not (= (fail) Parse_shen.<pattern1>)) (let Parse_shen.<pattern2> (shen.<pattern2> Parse_shen.<pattern1>) (if (not (= (fail) Parse_shen.<pattern2>)) (shen.pair (hd (shen.pair (shen.tlhd V1356) (shen.hdtl V1356))) (cons cons (cons (shen.hdtl Parse_shen.<pattern1>) (cons (shen.hdtl Parse_shen.<pattern2>) ())))) (fail))) (fail)))) (fail)) (fail)) (if (= YaccParse (fail)) (let YaccParse (if (and (cons? (hd V1356)) (cons? (shen.hdhd V1356))) (if (and (cons? (hd (shen.pair (shen.hdhd V1356) (shen.hdtl V1356)))) (= @v (shen.hdhd (shen.pair (shen.hdhd V1356) (shen.hdtl V1356))))) (let NewStream1349 (shen.pair (shen.tlhd (shen.pair (shen.hdhd V1356) (shen.hdtl V1356))) (shen.hdtl (shen.pair (shen.hdhd V1356) (shen.hdtl V1356)))) (let Parse_shen.<pattern1> (shen.<pattern1> NewStream1349) (if (not (= (fail) Parse_shen.<pattern1>)) (let Parse_shen.<pattern2> (shen.<pattern2> Parse_shen.<pattern1>) (if (not (= (fail) Parse_shen.<pattern2>)) (shen.pair (hd (shen.pair (shen.tlhd V1356) (shen.hdtl V1356))) (cons @v (cons (shen.hdtl Parse_shen.<pattern1>) (cons (shen.hdtl Parse_shen.<pattern2>) ())))) (fail))) (fail)))) (fail)) (fail)) (if (= YaccParse (fail)) (let YaccParse (if (and (cons? (hd V1356)) (cons? (shen.hdhd V1356))) (if (and (cons? (hd (shen.pair (shen.hdhd V1356) (shen.hdtl V1356)))) (= @s (shen.hdhd (shen.pair (shen.hdhd V1356) (shen.hdtl V1356))))) (let NewStream1351 (shen.pair (shen.tlhd (shen.pair (shen.hdhd V1356) (shen.hdtl V1356))) (shen.hdtl (shen.pair (shen.hdhd V1356) (shen.hdtl V1356)))) (let Parse_shen.<pattern1> (shen.<pattern1> NewStream1351) (if (not (= (fail) Parse_shen.<pattern1>)) (let Parse_shen.<pattern2> (shen.<pattern2> Parse_shen.<pattern1>) (if (not (= (fail) Parse_shen.<pattern2>)) (shen.pair (hd (shen.pair (shen.tlhd V1356) (shen.hdtl V1356))) (cons @s (cons (shen.hdtl Parse_shen.<pattern1>) (cons (shen.hdtl Parse_shen.<pattern2>) ())))) (fail))) (fail)))) (fail)) (fail)) (if (= YaccParse (fail)) (let YaccParse (if (and (cons? (hd V1356)) (cons? (shen.hdhd V1356))) (if (and (cons? (hd (shen.pair (shen.hdhd V1356) (shen.hdtl V1356)))) (= vector (shen.hdhd (shen.pair (shen.hdhd V1356) (shen.hdtl V1356))))) (let NewStream1353 (shen.pair (shen.tlhd (shen.pair (shen.hdhd V1356) (shen.hdtl V1356))) (shen.hdtl (shen.pair (shen.hdhd V1356) (shen.hdtl V1356)))) (if (and (cons? (hd NewStream1353)) (= 0 (shen.hdhd NewStream1353))) (let NewStream1354 (shen.pair (shen.tlhd NewStream1353) (shen.hdtl NewStream1353)) (shen.pair (hd (shen.pair (shen.tlhd V1356) (shen.hdtl V1356))) (cons vector (cons 0 ())))) (fail))) (fail)) (fail)) (if (= YaccParse (fail)) (let YaccParse (if (cons? (hd V1356)) (let Parse_X (shen.hdhd V1356) (if (cons? Parse_X) (shen.pair (hd (shen.pair (shen.tlhd V1356) (shen.hdtl V1356))) (shen.custom-pattern-compiler Parse_X (freeze (shen.constructor-error Parse_X)))) (fail))) (fail)) (if (= YaccParse (fail)) (let Parse_shen.<simple_pattern> (shen.<simple_pattern> V1356) (if (not (= (fail) Parse_shen.<simple_pattern>)) (shen.pair (hd Parse_shen.<simple_pattern>) (shen.hdtl Parse_shen.<simple_pattern>)) (fail))) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)))

(defun shen.constructor-error (V1358) (simple-error (shen.app V1358 " is not a legitimate constructor
" shen.a)))

(defun shen.<simple_pattern> (V1360) (let YaccParse (if (cons? (hd V1360)) (let Parse_X (shen.hdhd V1360) (if (= Parse_X _) (shen.pair (hd (shen.pair (shen.tlhd V1360) (shen.hdtl V1360))) (gensym Parse_Y)) (fail))) (fail)) (if (= YaccParse (fail)) (if (cons? (hd V1360)) (let Parse_X (shen.hdhd V1360) (if (not (element? Parse_X (cons -> (cons <- ())))) (shen.pair (hd (shen.pair (shen.tlhd V1360) (shen.hdtl V1360))) Parse_X) (fail))) (fail)) YaccParse)))

(defun shen.<pattern1> (V1362) (let Parse_shen.<pattern> (shen.<pattern> V1362) (if (not (= (fail) Parse_shen.<pattern>)) (shen.pair (hd Parse_shen.<pattern>) (shen.hdtl Parse_shen.<pattern>)) (fail))))

(defun shen.<pattern2> (V1364) (let Parse_shen.<pattern> (shen.<pattern> V1364) (if (not (= (fail) Parse_shen.<pattern>)) (shen.pair (hd Parse_shen.<pattern>) (shen.hdtl Parse_shen.<pattern>)) (fail))))

(defun shen.<action> (V1366) (if (cons? (hd V1366)) (let Parse_X (shen.hdhd V1366) (shen.pair (hd (shen.pair (shen.tlhd V1366) (shen.hdtl V1366))) Parse_X)) (fail)))

(defun shen.<guard> (V1368) (if (cons? (hd V1368)) (let Parse_X (shen.hdhd V1368) (shen.pair (hd (shen.pair (shen.tlhd V1368) (shen.hdtl V1368))) Parse_X)) (fail)))

(defun shen.compile_to_machine_code (V1371 V1372) (let Lambda+ (shen.compile_to_lambda+ V1371 V1372) (let KL (shen.compile_to_kl V1371 Lambda+) (let Record (shen.record-source V1371 KL) KL))))

(defun shen.record-source (V1377 V1378) (cond ((value shen.*installing-kl*) shen.skip) (true (put V1377 shen.source V1378 (value *property-vector*)))))

(defun shen.compile_to_lambda+ (V1381 V1382) (let Arity (shen.aritycheck V1381 V1382) (let UpDateSymbolTable (shen.update-symbol-table V1381 Arity) (let Free (shen.for-each (lambda Rule (shen.free_variable_check V1381 Rule)) V1382) (let Variables (shen.parameters Arity) (let Strip (map (lambda X (shen.strip-protect X)) V1382) (let Abstractions (map (lambda X (shen.abstract_rule X)) Strip) (let Applications (map (lambda X (shen.application_build Variables X)) Abstractions) (cons Variables (cons Applications ()))))))))))

(defun shen.update-symbol-table (V1385 V1386) (cond ((= 0 V1386) shen.skip) (true (put V1385 shen.lambda-form (eval-kl (shen.lambda-form V1385 V1386)) (value *property-vector*)))))

(defun shen.free_variable_check (V1389 V1390) (cond ((and (cons? V1390) (and (cons? (tl V1390)) (= () (tl (tl V1390))))) (let Bound (shen.extract_vars (hd V1390)) (let Free (shen.extract_free_vars Bound (hd (tl V1390))) (shen.free_variable_warnings V1389 Free)))) (true (shen.f_error shen.free_variable_check))))

(defun shen.extract_vars (V1392) (cond ((variable? V1392) (cons V1392 ())) ((cons? V1392) (union (shen.extract_vars (hd V1392)) (shen.extract_vars (tl V1392)))) (true ())))

(defun shen.extract_free_vars (V1404 V1405) (cond ((and (cons? V1405) (and (cons? (tl V1405)) (and (= () (tl (tl V1405))) (= (hd V1405) protect)))) ()) ((and (variable? V1405) (not (element? V1405 V1404))) (cons V1405 ())) ((and (cons? V1405) (and (= lambda (hd V1405)) (and (cons? (tl V1405)) (and (cons? (tl (tl V1405))) (= () (tl (tl (tl V1405)))))))) (shen.extract_free_vars (cons (hd (tl V1405)) V1404) (hd (tl (tl V1405))))) ((and (cons? V1405) (and (= let (hd V1405)) (and (cons? (tl V1405)) (and (cons? (tl (tl V1405))) (and (cons? (tl (tl (tl V1405)))) (= () (tl (tl (tl (tl V1405)))))))))) (union (shen.extract_free_vars V1404 (hd (tl (tl V1405)))) (shen.extract_free_vars (cons (hd (tl V1405)) V1404) (hd (tl (tl (tl V1405))))))) ((cons? V1405) (union (shen.extract_free_vars V1404 (hd V1405)) (shen.extract_free_vars V1404 (tl V1405)))) (true ())))

(defun shen.free_variable_warnings (V1410 V1411) (cond ((= () V1411) _) (true (simple-error (cn "error: the following variables are free in " (shen.app V1410 (cn ": " (shen.app (shen.list_variables V1411) "" shen.a)) shen.a))))))

(defun shen.list_variables (V1413) (cond ((and (cons? V1413) (= () (tl V1413))) (cn (str (hd V1413)) ".")) ((cons? V1413) (cn (str (hd V1413)) (cn ", " (shen.list_variables (tl V1413))))) (true (shen.f_error shen.list_variables))))

(defun shen.strip-protect (V1415) (cond ((and (cons? V1415) (and (cons? (tl V1415)) (and (= () (tl (tl V1415))) (= (hd V1415) protect)))) (shen.strip-protect (hd (tl V1415)))) ((cons? V1415) (map (lambda Z (shen.strip-protect Z)) V1415)) (true V1415)))

(defun shen.linearise (V1417) (cond ((and (cons? V1417) (and (cons? (tl V1417)) (= () (tl (tl V1417))))) (shen.linearise_help (shen.flatten (hd V1417)) (hd V1417) (hd (tl V1417)))) (true (shen.f_error shen.linearise))))

(defun shen.flatten (V1419) (cond ((= () V1419) ()) ((cons? V1419) (append (shen.flatten (hd V1419)) (shen.flatten (tl V1419)))) (true (cons V1419 ()))))

(defun shen.linearise_help (V1423 V1424 V1425) (cond ((= () V1423) (cons V1424 (cons V1425 ()))) ((cons? V1423) (if (and (variable? (hd V1423)) (element? (hd V1423) (tl V1423))) (let Var (gensym (hd V1423)) (let NewAction (cons where (cons (cons = (cons (hd V1423) (cons Var ()))) (cons V1425 ()))) (let NewPatts (shen.linearise_X (hd V1423) Var V1424) (shen.linearise_help (tl V1423) NewPatts NewAction)))) (shen.linearise_help (tl V1423) V1424 V1425))) (true (shen.f_error shen.linearise_help))))

(defun shen.linearise_X (V1438 V1439 V1440) (cond ((= V1440 V1438) V1439) ((cons? V1440) (let L (shen.linearise_X V1438 V1439 (hd V1440)) (if (= L (hd V1440)) (cons (hd V1440) (shen.linearise_X V1438 V1439 (tl V1440))) (cons L (tl V1440))))) (true V1440)))

(defun shen.aritycheck (V1443 V1444) (cond ((and (cons? V1444) (and (cons? (hd V1444)) (and (cons? (tl (hd V1444))) (and (= () (tl (tl (hd V1444)))) (= () (tl V1444)))))) (do (shen.aritycheck-action (hd (tl (hd V1444)))) (shen.aritycheck-name V1443 (arity V1443) (length (hd (hd V1444)))))) ((and (cons? V1444) (and (cons? (hd V1444)) (and (cons? (tl (hd V1444))) (and (= () (tl (tl (hd V1444)))) (and (cons? (tl V1444)) (and (cons? (hd (tl V1444))) (and (cons? (tl (hd (tl V1444)))) (= () (tl (tl (hd (tl V1444)))))))))))) (if (= (length (hd (hd V1444))) (length (hd (hd (tl V1444))))) (do (shen.aritycheck-action (hd (tl (hd V1444)))) (shen.aritycheck V1443 (tl V1444))) (simple-error (cn "arity error in " (shen.app V1443 "
" shen.a))))) (true (shen.f_error shen.aritycheck))))

(defun shen.aritycheck-name (V1457 V1458 V1459) (cond ((= -1 V1458) V1459) ((= V1459 V1458) V1459) (true (do (shen.prhush (cn "
warning: changing the arity of " (shen.app V1457 " can cause errors.
" shen.a)) (stoutput)) V1459))))

(defun shen.aritycheck-action (V1465) (cond ((cons? V1465) (do (shen.aah (hd V1465) (tl V1465)) (shen.for-each (lambda Y (shen.aritycheck-action Y)) V1465))) (true shen.skip)))

(defun shen.aah (V1468 V1469) (let Arity (arity V1468) (let Len (length V1469) (if (and (> Arity -1) (> Len Arity)) (shen.prhush (cn "warning: " (shen.app V1468 (cn " might not like " (shen.app Len (cn " argument" (shen.app (if (> Len 1) "s" "") ".
" shen.a)) shen.a)) shen.a)) (stoutput)) shen.skip))))

(defun shen.abstract_rule (V1471) (cond ((and (cons? V1471) (and (cons? (tl V1471)) (= () (tl (tl V1471))))) (shen.abstraction_build (hd V1471) (hd (tl V1471)))) (true (shen.f_error shen.abstract_rule))))

(defun shen.abstraction_build (V1474 V1475) (cond ((= () V1474) V1475) ((cons? V1474) (cons /. (cons (hd V1474) (cons (shen.abstraction_build (tl V1474) V1475) ())))) (true (shen.f_error shen.abstraction_build))))

(defun shen.parameters (V1477) (cond ((= 0 V1477) ()) (true (cons (gensym V) (shen.parameters (- V1477 1))))))

(defun shen.application_build (V1480 V1481) (cond ((= () V1480) V1481) ((cons? V1480) (shen.application_build (tl V1480) (cons V1481 (cons (hd V1480) ())))) (true (shen.f_error shen.application_build))))

(defun shen.compile_to_kl (V1484 V1485) (cond ((and (cons? V1485) (and (cons? (tl V1485)) (= () (tl (tl V1485))))) (let Arity (shen.store-arity V1484 (length (hd V1485))) (let Reduce (map (lambda X (shen.reduce X)) (hd (tl V1485))) (let CondExpression (shen.cond-expression V1484 (hd V1485) Reduce) (let TypeTable (if (value shen.*optimise*) (shen.typextable (shen.get-type V1484) (hd V1485)) shen.skip) (let TypedCondExpression (if (value shen.*optimise*) (shen.assign-types (hd V1485) TypeTable CondExpression) CondExpression) (cons defun (cons V1484 (cons (hd V1485) (cons TypedCondExpression ())))))))))) (true (shen.f_error shen.compile_to_kl))))

(defun shen.get-type (V1491) (cond ((cons? V1491) shen.skip) (true (let FType (assoc V1491 (value shen.*signedfuncs*)) (if (empty? FType) shen.skip (tl FType))))))

(defun shen.typextable (V1502 V1503) (cond ((and (cons? V1502) (and (cons? (tl V1502)) (and (= --> (hd (tl V1502))) (and (cons? (tl (tl V1502))) (and (= () (tl (tl (tl V1502)))) (cons? V1503)))))) (if (variable? (hd V1502)) (shen.typextable (hd (tl (tl V1502))) (tl V1503)) (cons (cons (hd V1503) (hd V1502)) (shen.typextable (hd (tl (tl V1502))) (tl V1503))))) (true ())))

(defun shen.assign-types (V1507 V1508 V1509) (cond ((and (cons? V1509) (and (= let (hd V1509)) (and (cons? (tl V1509)) (and (cons? (tl (tl V1509))) (and (cons? (tl (tl (tl V1509)))) (= () (tl (tl (tl (tl V1509)))))))))) (cons let (cons (hd (tl V1509)) (cons (shen.assign-types V1507 V1508 (hd (tl (tl V1509)))) (cons (shen.assign-types (cons (hd (tl V1509)) V1507) V1508 (hd (tl (tl (tl V1509))))) ()))))) ((and (cons? V1509) (and (= lambda (hd V1509)) (and (cons? (tl V1509)) (and (cons? (tl (tl V1509))) (= () (tl (tl (tl V1509)))))))) (cons lambda (cons (hd (tl V1509)) (cons (shen.assign-types (cons (hd (tl V1509)) V1507) V1508 (hd (tl (tl V1509)))) ())))) ((and (cons? V1509) (= cond (hd V1509))) (cons cond (map (lambda Y (cons (shen.assign-types V1507 V1508 (hd Y)) (cons (shen.assign-types V1507 V1508 (hd (tl Y))) ()))) (tl V1509)))) ((cons? V1509) (let NewTable (shen.typextable (shen.get-type (hd V1509)) (tl V1509)) (cons (hd V1509) (map (lambda Y (shen.assign-types V1507 (append V1508 NewTable) Y)) (tl V1509))))) (true (let AtomType (assoc V1509 V1508) (if (cons? AtomType) (cons type (cons V1509 (cons (tl AtomType) ()))) (if (element? V1509 V1507) V1509 (shen.atom-type V1509)))))))

(defun shen.atom-type (V1511) (if (string? V1511) (cons type (cons V1511 (cons string ()))) (if (number? V1511) (cons type (cons V1511 (cons number ()))) (if (boolean? V1511) (cons type (cons V1511 (cons boolean ()))) (if (symbol? V1511) (cons type (cons V1511 (cons symbol ()))) V1511)))))

(defun shen.store-arity (V1516 V1517) (cond ((value shen.*installing-kl*) shen.skip) (true (put V1516 arity V1517 (value *property-vector*)))))

(defun shen.reduce (V1519) (do (set shen.*teststack* ()) (let Result (shen.reduce_help V1519) (cons (cons : (cons shen.tests (reverse (value shen.*teststack*)))) (cons Result ())))))

(defun shen.reduce_help (V1521) (cond ((and (cons? V1521) (and (cons? (hd V1521)) (and (= /. (hd (hd V1521))) (and (cons? (tl (hd V1521))) (and (cons? (hd (tl (hd V1521)))) (and (= cons (hd (hd (tl (hd V1521))))) (and (cons? (tl (hd (tl (hd V1521))))) (and (cons? (tl (tl (hd (tl (hd V1521)))))) (and (= () (tl (tl (tl (hd (tl (hd V1521))))))) (and (cons? (tl (tl (hd V1521)))) (and (= () (tl (tl (tl (hd V1521))))) (and (cons? (tl V1521)) (= () (tl (tl V1521))))))))))))))) (do (shen.add_test (cons cons? (tl V1521))) (let Abstraction (cons /. (cons (hd (tl (hd (tl (hd V1521))))) (cons (cons /. (cons (hd (tl (tl (hd (tl (hd V1521)))))) (cons (shen.ebr (hd (tl V1521)) (hd (tl (hd V1521))) (hd (tl (tl (hd V1521))))) ()))) ()))) (let Application (cons (cons Abstraction (cons (cons hd (tl V1521)) ())) (cons (cons tl (tl V1521)) ())) (shen.reduce_help Application))))) ((and (cons? V1521) (and (cons? (hd V1521)) (and (= /. (hd (hd V1521))) (and (cons? (tl (hd V1521))) (and (cons? (hd (tl (hd V1521)))) (and (= @p (hd (hd (tl (hd V1521))))) (and (cons? (tl (hd (tl (hd V1521))))) (and (cons? (tl (tl (hd (tl (hd V1521)))))) (and (= () (tl (tl (tl (hd (tl (hd V1521))))))) (and (cons? (tl (tl (hd V1521)))) (and (= () (tl (tl (tl (hd V1521))))) (and (cons? (tl V1521)) (= () (tl (tl V1521))))))))))))))) (do (shen.add_test (cons tuple? (tl V1521))) (let Abstraction (cons /. (cons (hd (tl (hd (tl (hd V1521))))) (cons (cons /. (cons (hd (tl (tl (hd (tl (hd V1521)))))) (cons (shen.ebr (hd (tl V1521)) (hd (tl (hd V1521))) (hd (tl (tl (hd V1521))))) ()))) ()))) (let Application (cons (cons Abstraction (cons (cons fst (tl V1521)) ())) (cons (cons snd (tl V1521)) ())) (shen.reduce_help Application))))) ((and (cons? V1521) (and (cons? (hd V1521)) (and (= /. (hd (hd V1521))) (and (cons? (tl (hd V1521))) (and (cons? (hd (tl (hd V1521)))) (and (= @v (hd (hd (tl (hd V1521))))) (and (cons? (tl (hd (tl (hd V1521))))) (and (cons? (tl (tl (hd (tl (hd V1521)))))) (and (= () (tl (tl (tl (hd (tl (hd V1521))))))) (and (cons? (tl (tl (hd V1521)))) (and (= () (tl (tl (tl (hd V1521))))) (and (cons? (tl V1521)) (= () (tl (tl V1521))))))))))))))) (do (shen.add_test (cons shen.+vector? (tl V1521))) (let Abstraction (cons /. (cons (hd (tl (hd (tl (hd V1521))))) (cons (cons /. (cons (hd (tl (tl (hd (tl (hd V1521)))))) (cons (shen.ebr (hd (tl V1521)) (hd (tl (hd V1521))) (hd (tl (tl (hd V1521))))) ()))) ()))) (let Application (cons (cons Abstraction (cons (cons hdv (tl V1521)) ())) (cons (cons tlv (tl V1521)) ())) (shen.reduce_help Application))))) ((and (cons? V1521) (and (cons? (hd V1521)) (and (= /. (hd (hd V1521))) (and (cons? (tl (hd V1521))) (and (cons? (hd (tl (hd V1521)))) (and (= @s (hd (hd (tl (hd V1521))))) (and (cons? (tl (hd (tl (hd V1521))))) (and (cons? (tl (tl (hd (tl (hd V1521)))))) (and (= () (tl (tl (tl (hd (tl (hd V1521))))))) (and (cons? (tl (tl (hd V1521)))) (and (= () (tl (tl (tl (hd V1521))))) (and (cons? (tl V1521)) (= () (tl (tl V1521))))))))))))))) (do (shen.add_test (cons shen.+string? (tl V1521))) (let Abstraction (cons /. (cons (hd (tl (hd (tl (hd V1521))))) (cons (cons /. (cons (hd (tl (tl (hd (tl (hd V1521)))))) (cons (shen.ebr (hd (tl V1521)) (hd (tl (hd V1521))) (hd (tl (tl (hd V1521))))) ()))) ()))) (let Application (cons (cons Abstraction (cons (cons pos (cons (hd (tl V1521)) (cons 0 ()))) ())) (cons (cons tlstr (tl V1521)) ())) (shen.reduce_help Application))))) ((and (cons? V1521) (and (cons? (hd V1521)) (and (= /. (hd (hd V1521))) (and (cons? (tl (hd V1521))) (and (cons? (hd (tl (hd V1521)))) (and (= vector (hd (hd (tl (hd V1521))))) (and (cons? (tl (hd (tl (hd V1521))))) (and (= 0 (hd (tl (hd (tl (hd V1521)))))) (and (= () (tl (tl (hd (tl (hd V1521)))))) (and (cons? (tl (tl (hd V1521)))) (and (= () (tl (tl (tl (hd V1521))))) (and (cons? (tl V1521)) (= () (tl (tl V1521))))))))))))))) (do (shen.add_test (cons vector? (tl V1521))) (do (shen.add_test (cons = (cons 0 (cons (cons limit (tl V1521)) ())))) (shen.reduce_help (shen.ebr (hd (tl V1521)) (hd (tl (hd V1521))) (hd (tl (tl (hd V1521))))))))) ((and (cons? V1521) (and (cons? (hd V1521)) (and (= /. (hd (hd V1521))) (and (cons? (tl (hd V1521))) (and (cons? (hd (tl (hd V1521)))) (and (cons? (tl (tl (hd V1521)))) (and (= () (tl (tl (tl (hd V1521))))) (and (cons? (tl V1521)) (= () (tl (tl V1521))))))))))) (shen.custom-pattern-reducer V1521)) ((and (cons? V1521) (and (cons? (hd V1521)) (and (= /. (hd (hd V1521))) (and (cons? (tl (hd V1521))) (and (cons? (tl (tl (hd V1521)))) (and (= () (tl (tl (tl (hd V1521))))) (and (cons? (tl V1521)) (and (= () (tl (tl V1521))) (not (variable? (hd (tl (hd V1521))))))))))))) (do (shen.add_test (cons = (cons (hd (tl (hd V1521))) (tl V1521)))) (shen.reduce_help (hd (tl (tl (hd V1521))))))) ((and (cons? V1521) (and (cons? (hd V1521)) (and (= /. (hd (hd V1521))) (and (cons? (tl (hd V1521))) (and (cons? (tl (tl (hd V1521)))) (and (= () (tl (tl (tl (hd V1521))))) (and (cons? (tl V1521)) (= () (tl (tl V1521)))))))))) (shen.reduce_help (shen.ebr (hd (tl V1521)) (hd (tl (hd V1521))) (hd (tl (tl (hd V1521))))))) ((and (cons? V1521) (and (= where (hd V1521)) (and (cons? (tl V1521)) (and (cons? (tl (tl V1521))) (= () (tl (tl (tl V1521)))))))) (do (shen.add_test (hd (tl V1521))) (shen.reduce_help (hd (tl (tl V1521)))))) ((and (cons? V1521) (and (cons? (tl V1521)) (= () (tl (tl V1521))))) (let Z (shen.reduce_help (hd V1521)) (if (= (hd V1521) Z) V1521 (shen.reduce_help (cons Z (tl V1521)))))) (true V1521)))

(defun shen.+string? (V1523) (cond ((= "" V1523) false) (true (string? V1523))))

(defun shen.+vector? (V1525) (and (absvector? V1525) (> (<-address V1525 0) 0)))

(defun shen.ebr (V1538 V1539 V1540) (cond ((= V1540 V1539) V1538) ((and (cons? V1540) (and (= lambda (hd V1540)) (and (cons? (tl V1540)) (and (cons? (tl (tl V1540))) (and (= () (tl (tl (tl V1540)))) (shen.clash? (hd (tl V1540)) V1539)))))) V1540) ((and (cons? V1540) (and (= let (hd V1540)) (and (cons? (tl V1540)) (and (cons? (tl (tl V1540))) (and (cons? (tl (tl (tl V1540)))) (and (= () (tl (tl (tl (tl V1540))))) (shen.clash? (hd (tl V1540)) V1539))))))) (cons let (cons (hd (tl V1540)) (cons (shen.ebr V1538 V1539 (hd (tl (tl V1540)))) (tl (tl (tl V1540))))))) ((cons? V1540) (cons (shen.ebr V1538 V1539 (hd V1540)) (shen.ebr V1538 V1539 (tl V1540)))) (true V1540)))

(defun shen.clash? (V1552 V1553) (cond ((= V1553 V1552) true) ((cons? V1553) (or (shen.clash? V1552 (hd V1553)) (shen.clash? V1552 (tl V1553)))) (true false)))

(defun shen.add_test (V1555) (set shen.*teststack* (cons V1555 (value shen.*teststack*))))

(defun shen.cond-expression (V1559 V1560 V1561) (let Err (shen.err-condition V1559) (let Cases (shen.case-form V1561 Err) (let EncodeChoices (shen.encode-choices Cases V1559) (shen.cond-form EncodeChoices)))))

(defun shen.cond-form (V1565) (cond ((and (cons? V1565) (and (cons? (hd V1565)) (and (= true (hd (hd V1565))) (and (cons? (tl (hd V1565))) (= () (tl (tl (hd V1565)))))))) (hd (tl (hd V1565)))) (true (cons cond V1565))))

(defun shen.encode-choices (V1570 V1571) (cond ((= () V1570) ()) ((and (cons? V1570) (and (cons? (hd V1570)) (and (= true (hd (hd V1570))) (and (cons? (tl (hd V1570))) (and (cons? (hd (tl (hd V1570)))) (and (= shen.choicepoint! (hd (hd (tl (hd V1570))))) (and (cons? (tl (hd (tl (hd V1570))))) (and (= () (tl (tl (hd (tl (hd V1570)))))) (and (= () (tl (tl (hd V1570)))) (= () (tl V1570))))))))))) (cons (cons true (cons (cons let (cons Result (cons (hd (tl (hd (tl (hd V1570))))) (cons (cons if (cons (cons = (cons Result (cons (cons fail ()) ()))) (cons (if (value shen.*installing-kl*) (cons shen.sys-error (cons V1571 ())) (cons shen.f_error (cons V1571 ()))) (cons Result ())))) ())))) ())) ())) ((and (cons? V1570) (and (cons? (hd V1570)) (and (= true (hd (hd V1570))) (and (cons? (tl (hd V1570))) (and (cons? (hd (tl (hd V1570)))) (and (= shen.choicepoint! (hd (hd (tl (hd V1570))))) (and (cons? (tl (hd (tl (hd V1570))))) (and (= () (tl (tl (hd (tl (hd V1570)))))) (= () (tl (tl (hd V1570)))))))))))) (cons (cons true (cons (cons let (cons Result (cons (hd (tl (hd (tl (hd V1570))))) (cons (cons if (cons (cons = (cons Result (cons (cons fail ()) ()))) (cons (shen.cond-form (shen.encode-choices (tl V1570) V1571)) (cons Result ())))) ())))) ())) ())) ((and (cons? V1570) (and (cons? (hd V1570)) (and (cons? (tl (hd V1570))) (and (cons? (hd (tl (hd V1570)))) (and (= shen.choicepoint! (hd (hd (tl (hd V1570))))) (and (cons? (tl (hd (tl (hd V1570))))) (and (= () (tl (tl (hd (tl (hd V1570)))))) (= () (tl (tl (hd V1570))))))))))) (cons (cons true (cons (cons let (cons Freeze (cons (cons freeze (cons (shen.cond-form (shen.encode-choices (tl V1570) V1571)) ())) (cons (cons if (cons (hd (hd V1570)) (cons (cons let (cons Result (cons (hd (tl (hd (tl (hd V1570))))) (cons (cons if (cons (cons = (cons Result (cons (cons fail ()) ()))) (cons (cons thaw (cons Freeze ())) (cons Result ())))) ())))) (cons (cons thaw (cons Freeze ())) ())))) ())))) ())) ())) ((and (cons? V1570) (and (cons? (hd V1570)) (and (cons? (tl (hd V1570))) (= () (tl (tl (hd V1570))))))) (cons (hd V1570) (shen.encode-choices (tl V1570) V1571))) (true (shen.f_error shen.encode-choices))))

(defun shen.case-form (V1578 V1579) (cond ((= () V1578) (cons V1579 ())) ((and (cons? V1578) (and (cons? (hd V1578)) (and (cons? (hd (hd V1578))) (and (= : (hd (hd (hd V1578)))) (and (cons? (tl (hd (hd V1578)))) (and (= shen.tests (hd (tl (hd (hd V1578))))) (and (= () (tl (tl (hd (hd V1578))))) (and (cons? (tl (hd V1578))) (and (cons? (hd (tl (hd V1578)))) (and (= shen.choicepoint! (hd (hd (tl (hd V1578))))) (and (cons? (tl (hd (tl (hd V1578))))) (and (= () (tl (tl (hd (tl (hd V1578)))))) (= () (tl (tl (hd V1578)))))))))))))))) (cons (cons true (tl (hd V1578))) (shen.case-form (tl V1578) V1579))) ((and (cons? V1578) (and (cons? (hd V1578)) (and (cons? (hd (hd V1578))) (and (= : (hd (hd (hd V1578)))) (and (cons? (tl (hd (hd V1578)))) (and (= shen.tests (hd (tl (hd (hd V1578))))) (and (= () (tl (tl (hd (hd V1578))))) (and (cons? (tl (hd V1578))) (= () (tl (tl (hd V1578)))))))))))) (cons (cons true (tl (hd V1578))) ())) ((and (cons? V1578) (and (cons? (hd V1578)) (and (cons? (hd (hd V1578))) (and (= : (hd (hd (hd V1578)))) (and (cons? (tl (hd (hd V1578)))) (and (= shen.tests (hd (tl (hd (hd V1578))))) (and (cons? (tl (hd V1578))) (= () (tl (tl (hd V1578))))))))))) (cons (cons (shen.embed-and (tl (tl (hd (hd V1578))))) (tl (hd V1578))) (shen.case-form (tl V1578) V1579))) (true (shen.f_error shen.case-form))))

(defun shen.embed-and (V1581) (cond ((and (cons? V1581) (= () (tl V1581))) (hd V1581)) ((cons? V1581) (cons and (cons (hd V1581) (cons (shen.embed-and (tl V1581)) ())))) (true (shen.f_error shen.embed-and))))

(defun shen.err-condition (V1583) (cons true (cons (cons shen.f_error (cons V1583 ())) ())))

(defun shen.sys-error (V1585) (simple-error (cn "system function " (shen.app V1585 ": unexpected argument
" shen.a))))



