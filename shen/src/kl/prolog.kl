"Copyright (c) 2010-2015, Mark Tarver

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice,
this list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation
and/or other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its contributors
may be used to endorse or promote products derived from this software without
specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ''AS IS'' AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
"

(defun shen.<defprolog> (V2003) (let Parse_shen.<predicate*> (shen.<predicate*> V2003) (if (not (= (fail) Parse_shen.<predicate*>)) (let Parse_shen.<clauses*> (shen.<clauses*> Parse_shen.<predicate*>) (if (not (= (fail) Parse_shen.<clauses*>)) (shen.pair (hd Parse_shen.<clauses*>) (hd (shen.prolog->shen (map (lambda Parse_X (shen.insert-predicate (shen.hdtl Parse_shen.<predicate*>) Parse_X)) (shen.hdtl Parse_shen.<clauses*>))))) (fail))) (fail))))

(defun shen.prolog-error (V2012 V2013) (cond ((and (cons? V2013) (and (cons? (tl V2013)) (= () (tl (tl V2013))))) (simple-error (cn "prolog syntax error in " (shen.app V2012 (cn " here:

 " (shen.app (shen.next-50 50 (hd V2013)) "
" shen.a)) shen.a)))) (true (simple-error (cn "prolog syntax error in " (shen.app V2012 "
" shen.a))))))

(defun shen.next-50 (V2020 V2021) (cond ((= () V2021) "") ((= 0 V2020) "") ((cons? V2021) (cn (shen.decons-string (hd V2021)) (shen.next-50 (- V2020 1) (tl V2021)))) (true (shen.f_error shen.next-50))))

(defun shen.decons-string (V2023) (cond ((and (cons? V2023) (and (= cons (hd V2023)) (and (cons? (tl V2023)) (and (cons? (tl (tl V2023))) (= () (tl (tl (tl V2023)))))))) (shen.app (shen.eval-cons V2023) " " shen.s)) (true (shen.app V2023 " " shen.r))))

(defun shen.insert-predicate (V2026 V2027) (cond ((and (cons? V2027) (and (cons? (tl V2027)) (= () (tl (tl V2027))))) (cons (cons V2026 (hd V2027)) (cons :- (tl V2027)))) (true (shen.f_error shen.insert-predicate))))

(defun shen.<predicate*> (V2029) (if (cons? (hd V2029)) (let Parse_X (shen.hdhd V2029) (shen.pair (hd (shen.pair (shen.tlhd V2029) (shen.hdtl V2029))) Parse_X)) (fail)))

(defun shen.<clauses*> (V2031) (let YaccParse (let Parse_shen.<clause*> (shen.<clause*> V2031) (if (not (= (fail) Parse_shen.<clause*>)) (let Parse_shen.<clauses*> (shen.<clauses*> Parse_shen.<clause*>) (if (not (= (fail) Parse_shen.<clauses*>)) (shen.pair (hd Parse_shen.<clauses*>) (cons (shen.hdtl Parse_shen.<clause*>) (shen.hdtl Parse_shen.<clauses*>))) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_<e> (<e> V2031) (if (not (= (fail) Parse_<e>)) (shen.pair (hd Parse_<e>) ()) (fail))) YaccParse)))

(defun shen.<clause*> (V2034) (let Parse_shen.<head*> (shen.<head*> V2034) (if (not (= (fail) Parse_shen.<head*>)) (if (and (cons? (hd Parse_shen.<head*>)) (= <-- (shen.hdhd Parse_shen.<head*>))) (let NewStream2032 (shen.pair (shen.tlhd Parse_shen.<head*>) (shen.hdtl Parse_shen.<head*>)) (let Parse_shen.<body*> (shen.<body*> NewStream2032) (if (not (= (fail) Parse_shen.<body*>)) (let Parse_shen.<end*> (shen.<end*> Parse_shen.<body*>) (if (not (= (fail) Parse_shen.<end*>)) (shen.pair (hd Parse_shen.<end*>) (cons (shen.hdtl Parse_shen.<head*>) (cons (shen.hdtl Parse_shen.<body*>) ()))) (fail))) (fail)))) (fail)) (fail))))

(defun shen.<head*> (V2036) (let YaccParse (let Parse_shen.<term*> (shen.<term*> V2036) (if (not (= (fail) Parse_shen.<term*>)) (let Parse_shen.<head*> (shen.<head*> Parse_shen.<term*>) (if (not (= (fail) Parse_shen.<head*>)) (shen.pair (hd Parse_shen.<head*>) (cons (shen.hdtl Parse_shen.<term*>) (shen.hdtl Parse_shen.<head*>))) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_<e> (<e> V2036) (if (not (= (fail) Parse_<e>)) (shen.pair (hd Parse_<e>) ()) (fail))) YaccParse)))

(defun shen.<term*> (V2038) (if (cons? (hd V2038)) (let Parse_X (shen.hdhd V2038) (if (and (not (= <-- Parse_X)) (shen.legitimate-term? Parse_X)) (shen.pair (hd (shen.pair (shen.tlhd V2038) (shen.hdtl V2038))) (shen.eval-cons Parse_X)) (fail))) (fail)))

(defun shen.legitimate-term? (V2044) (cond ((and (cons? V2044) (and (= cons (hd V2044)) (and (cons? (tl V2044)) (and (cons? (tl (tl V2044))) (= () (tl (tl (tl V2044)))))))) (and (shen.legitimate-term? (hd (tl V2044))) (shen.legitimate-term? (hd (tl (tl V2044)))))) ((and (cons? V2044) (and (= mode (hd V2044)) (and (cons? (tl V2044)) (and (cons? (tl (tl V2044))) (and (= + (hd (tl (tl V2044)))) (= () (tl (tl (tl V2044))))))))) (shen.legitimate-term? (hd (tl V2044)))) ((and (cons? V2044) (and (= mode (hd V2044)) (and (cons? (tl V2044)) (and (cons? (tl (tl V2044))) (and (= - (hd (tl (tl V2044)))) (= () (tl (tl (tl V2044))))))))) (shen.legitimate-term? (hd (tl V2044)))) ((cons? V2044) false) (true true)))

(defun shen.eval-cons (V2046) (cond ((and (cons? V2046) (and (= cons (hd V2046)) (and (cons? (tl V2046)) (and (cons? (tl (tl V2046))) (= () (tl (tl (tl V2046)))))))) (cons (shen.eval-cons (hd (tl V2046))) (shen.eval-cons (hd (tl (tl V2046)))))) ((and (cons? V2046) (and (= mode (hd V2046)) (and (cons? (tl V2046)) (and (cons? (tl (tl V2046))) (= () (tl (tl (tl V2046)))))))) (cons mode (cons (shen.eval-cons (hd (tl V2046))) (tl (tl V2046))))) (true V2046)))

(defun shen.<body*> (V2048) (let YaccParse (let Parse_shen.<literal*> (shen.<literal*> V2048) (if (not (= (fail) Parse_shen.<literal*>)) (let Parse_shen.<body*> (shen.<body*> Parse_shen.<literal*>) (if (not (= (fail) Parse_shen.<body*>)) (shen.pair (hd Parse_shen.<body*>) (cons (shen.hdtl Parse_shen.<literal*>) (shen.hdtl Parse_shen.<body*>))) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_<e> (<e> V2048) (if (not (= (fail) Parse_<e>)) (shen.pair (hd Parse_<e>) ()) (fail))) YaccParse)))

(defun shen.<literal*> (V2051) (let YaccParse (if (and (cons? (hd V2051)) (= ! (shen.hdhd V2051))) (let NewStream2049 (shen.pair (shen.tlhd V2051) (shen.hdtl V2051)) (shen.pair (hd NewStream2049) (cons cut (cons (intern "Throwcontrol") ())))) (fail)) (if (= YaccParse (fail)) (if (cons? (hd V2051)) (let Parse_X (shen.hdhd V2051) (if (cons? Parse_X) (shen.pair (hd (shen.pair (shen.tlhd V2051) (shen.hdtl V2051))) Parse_X) (fail))) (fail)) YaccParse)))

(defun shen.<end*> (V2053) (if (cons? (hd V2053)) (let Parse_X (shen.hdhd V2053) (if (= Parse_X ;) (shen.pair (hd (shen.pair (shen.tlhd V2053) (shen.hdtl V2053))) Parse_X) (fail))) (fail)))

(defun cut (V2057 V2058 V2059) (let Result (thaw V2059) (if (= Result false) V2057 Result)))

(defun shen.insert_modes (V2061) (cond ((and (cons? V2061) (and (= mode (hd V2061)) (and (cons? (tl V2061)) (and (cons? (tl (tl V2061))) (= () (tl (tl (tl V2061)))))))) V2061) ((= () V2061) ()) ((cons? V2061) (cons (cons mode (cons (hd V2061) (cons + ()))) (cons mode (cons (shen.insert_modes (tl V2061)) (cons - ()))))) (true V2061)))

(defun shen.s-prolog (V2063) (map (lambda X (eval X)) (shen.prolog->shen V2063)))

(defun shen.prolog->shen (V2065) (map (lambda X (shen.compile_prolog_procedure X)) (shen.group_clauses (map (lambda X (shen.s-prolog_clause X)) (mapcan (lambda X (shen.head_abstraction X)) V2065)))))

(defun shen.s-prolog_clause (V2067) (cond ((and (cons? V2067) (and (cons? (tl V2067)) (and (= :- (hd (tl V2067))) (and (cons? (tl (tl V2067))) (= () (tl (tl (tl V2067)))))))) (cons (hd V2067) (cons :- (cons (map (lambda X (shen.s-prolog_literal X)) (hd (tl (tl V2067)))) ())))) (true (shen.f_error shen.s-prolog_clause))))

(defun shen.head_abstraction (V2069) (cond ((and (cons? V2069) (and (cons? (tl V2069)) (and (= :- (hd (tl V2069))) (and (cons? (tl (tl V2069))) (and (= () (tl (tl (tl V2069)))) (trap-error (< (shen.complexity_head (hd V2069)) (value shen.*maxcomplexity*)) (lambda _ false))))))) (cons V2069 ())) ((and (cons? V2069) (and (cons? (hd V2069)) (and (cons? (tl V2069)) (and (= :- (hd (tl V2069))) (and (cons? (tl (tl V2069))) (= () (tl (tl (tl V2069))))))))) (let Terms (map (lambda Y (gensym V)) (tl (hd V2069))) (let XTerms (shen.rcons_form (shen.remove_modes (tl (hd V2069)))) (let Literal (cons unify (cons (shen.cons_form Terms) (cons XTerms ()))) (let Clause (cons (cons (hd (hd V2069)) Terms) (cons :- (cons (cons Literal (hd (tl (tl V2069)))) ()))) (cons Clause ())))))) (true (shen.f_error shen.head_abstraction))))

(defun shen.complexity_head (V2075) (cond ((cons? V2075) (shen.safe-product (map (lambda X (shen.complexity X)) (tl V2075)))) (true (shen.f_error shen.complexity_head))))

(defun shen.safe-multiply (V2078 V2079) (* V2078 V2079))

(defun shen.complexity (V2088) (cond ((and (cons? V2088) (and (= mode (hd V2088)) (and (cons? (tl V2088)) (and (cons? (hd (tl V2088))) (and (= mode (hd (hd (tl V2088)))) (and (cons? (tl (hd (tl V2088)))) (and (cons? (tl (tl (hd (tl V2088))))) (and (= () (tl (tl (tl (hd (tl V2088)))))) (and (cons? (tl (tl V2088))) (= () (tl (tl (tl V2088))))))))))))) (shen.complexity (hd (tl V2088)))) ((and (cons? V2088) (and (= mode (hd V2088)) (and (cons? (tl V2088)) (and (cons? (hd (tl V2088))) (and (cons? (tl (tl V2088))) (and (= + (hd (tl (tl V2088)))) (= () (tl (tl (tl V2088)))))))))) (shen.safe-multiply 2 (shen.safe-multiply (shen.complexity (cons mode (cons (hd (hd (tl V2088))) (tl (tl V2088))))) (shen.complexity (cons mode (cons (tl (hd (tl V2088))) (tl (tl V2088)))))))) ((and (cons? V2088) (and (= mode (hd V2088)) (and (cons? (tl V2088)) (and (cons? (hd (tl V2088))) (and (cons? (tl (tl V2088))) (and (= - (hd (tl (tl V2088)))) (= () (tl (tl (tl V2088)))))))))) (shen.safe-multiply (shen.complexity (cons mode (cons (hd (hd (tl V2088))) (tl (tl V2088))))) (shen.complexity (cons mode (cons (tl (hd (tl V2088))) (tl (tl V2088))))))) ((and (cons? V2088) (and (= mode (hd V2088)) (and (cons? (tl V2088)) (and (cons? (tl (tl V2088))) (and (= () (tl (tl (tl V2088)))) (variable? (hd (tl V2088)))))))) 1) ((and (cons? V2088) (and (= mode (hd V2088)) (and (cons? (tl V2088)) (and (cons? (tl (tl V2088))) (and (= + (hd (tl (tl V2088)))) (= () (tl (tl (tl V2088))))))))) 2) ((and (cons? V2088) (and (= mode (hd V2088)) (and (cons? (tl V2088)) (and (cons? (tl (tl V2088))) (and (= - (hd (tl (tl V2088)))) (= () (tl (tl (tl V2088))))))))) 1) (true (shen.complexity (cons mode (cons V2088 (cons + ())))))))

(defun shen.safe-product (V2090) (cond ((= () V2090) 1) ((cons? V2090) (shen.safe-multiply (hd V2090) (shen.safe-product (tl V2090)))) (true (shen.f_error shen.safe-product))))

(defun shen.s-prolog_literal (V2092) (cond ((and (cons? V2092) (and (= is (hd V2092)) (and (cons? (tl V2092)) (and (cons? (tl (tl V2092))) (= () (tl (tl (tl V2092)))))))) (cons bind (cons (hd (tl V2092)) (cons (shen.insert-deref (hd (tl (tl V2092))) ProcessN) ())))) ((and (cons? V2092) (and (= when (hd V2092)) (and (cons? (tl V2092)) (= () (tl (tl V2092)))))) (cons fwhen (cons (shen.insert-deref (hd (tl V2092)) ProcessN) ()))) ((and (cons? V2092) (and (= bind (hd V2092)) (and (cons? (tl V2092)) (and (cons? (tl (tl V2092))) (= () (tl (tl (tl V2092)))))))) (cons bind (cons (hd (tl V2092)) (cons (shen.insert-lazyderef (hd (tl (tl V2092))) ProcessN) ())))) ((and (cons? V2092) (and (= fwhen (hd V2092)) (and (cons? (tl V2092)) (= () (tl (tl V2092)))))) (cons fwhen (cons (shen.insert-lazyderef (hd (tl V2092)) ProcessN) ()))) ((cons? V2092) V2092) (true (shen.f_error shen.s-prolog_literal))))

(defun shen.insert-deref (V2099 V2100) (cond ((variable? V2099) (cons shen.deref (cons V2099 (cons V2100 ())))) ((and (cons? V2099) (and (= lambda (hd V2099)) (and (cons? (tl V2099)) (and (cons? (tl (tl V2099))) (= () (tl (tl (tl V2099)))))))) (cons lambda (cons (hd (tl V2099)) (cons (shen.insert-deref (hd (tl (tl V2099))) V2100) ())))) ((and (cons? V2099) (and (= let (hd V2099)) (and (cons? (tl V2099)) (and (cons? (tl (tl V2099))) (and (cons? (tl (tl (tl V2099)))) (= () (tl (tl (tl (tl V2099)))))))))) (cons let (cons (hd (tl V2099)) (cons (shen.insert-deref (hd (tl (tl V2099))) V2100) (cons (shen.insert-deref (hd (tl (tl (tl V2099)))) V2100) ()))))) ((cons? V2099) (cons (shen.insert-deref (hd V2099) V2100) (shen.insert-deref (tl V2099) V2100))) (true V2099)))

(defun shen.insert-lazyderef (V2107 V2108) (cond ((variable? V2107) (cons shen.lazyderef (cons V2107 (cons V2108 ())))) ((and (cons? V2107) (and (= lambda (hd V2107)) (and (cons? (tl V2107)) (and (cons? (tl (tl V2107))) (= () (tl (tl (tl V2107)))))))) (cons lambda (cons (hd (tl V2107)) (cons (shen.insert-lazyderef (hd (tl (tl V2107))) V2108) ())))) ((and (cons? V2107) (and (= let (hd V2107)) (and (cons? (tl V2107)) (and (cons? (tl (tl V2107))) (and (cons? (tl (tl (tl V2107)))) (= () (tl (tl (tl (tl V2107)))))))))) (cons let (cons (hd (tl V2107)) (cons (shen.insert-lazyderef (hd (tl (tl V2107))) V2108) (cons (shen.insert-lazyderef (hd (tl (tl (tl V2107)))) V2108) ()))))) ((cons? V2107) (cons (shen.insert-lazyderef (hd V2107) V2108) (shen.insert-lazyderef (tl V2107) V2108))) (true V2107)))

(defun shen.group_clauses (V2110) (cond ((= () V2110) ()) ((cons? V2110) (let Group (shen.collect (lambda X (shen.same_predicate? (hd V2110) X)) V2110) (let Rest (difference V2110 Group) (cons Group (shen.group_clauses Rest))))) (true (shen.f_error shen.group_clauses))))

(defun shen.collect (V2115 V2116) (cond ((= () V2116) ()) ((cons? V2116) (if (V2115 (hd V2116)) (cons (hd V2116) (shen.collect V2115 (tl V2116))) (shen.collect V2115 (tl V2116)))) (true (shen.f_error shen.collect))))

(defun shen.same_predicate? (V2135 V2136) (cond ((and (cons? V2135) (and (cons? (hd V2135)) (and (cons? V2136) (cons? (hd V2136))))) (= (hd (hd V2135)) (hd (hd V2136)))) (true (shen.f_error shen.same_predicate?))))

(defun shen.compile_prolog_procedure (V2138) (let F (shen.procedure_name V2138) (let Shen (shen.clauses-to-shen F V2138) Shen)))

(defun shen.procedure_name (V2152) (cond ((and (cons? V2152) (and (cons? (hd V2152)) (cons? (hd (hd V2152))))) (hd (hd (hd V2152)))) (true (shen.f_error shen.procedure_name))))

(defun shen.clauses-to-shen (V2155 V2156) (let Linear (map (lambda X (shen.linearise-clause X)) V2156) (let Arity (shen.prolog-aritycheck V2155 (map (lambda X (head X)) V2156)) (let Parameters (shen.parameters Arity) (let AUM_instructions (map (lambda X (shen.aum X Parameters)) Linear) (let Code (shen.catch-cut (shen.nest-disjunct (map (lambda X (shen.aum_to_shen X)) AUM_instructions))) (let ShenDef (cons define (cons V2155 (append Parameters (append (cons ProcessN (cons Continuation ())) (cons -> (cons Code ())))))) ShenDef)))))))

(defun shen.catch-cut (V2158) (cond ((not (shen.occurs? cut V2158)) V2158) (true (cons let (cons Throwcontrol (cons (cons shen.catchpoint ()) (cons (cons shen.cutpoint (cons Throwcontrol (cons V2158 ()))) ())))))))

(defun shen.catchpoint () (cons shen.catchpoint! (set shen.*catch* (+ 1 (value shen.*catch*)))))

(defun shen.cutpoint (V2166 V2167) (cond ((= V2167 V2166) false) (true V2167)))

(defun shen.nest-disjunct (V2169) (cond ((and (cons? V2169) (= () (tl V2169))) (hd V2169)) ((cons? V2169) (shen.lisp-or (hd V2169) (shen.nest-disjunct (tl V2169)))) (true (shen.f_error shen.nest-disjunct))))

(defun shen.lisp-or (V2172 V2173) (cons let (cons Case (cons V2172 (cons (cons if (cons (cons = (cons Case (cons false ()))) (cons V2173 (cons Case ())))) ())))))

(defun shen.prolog-aritycheck (V2178 V2179) (cond ((and (cons? V2179) (= () (tl V2179))) (- (length (hd V2179)) 1)) ((and (cons? V2179) (cons? (tl V2179))) (if (= (length (hd V2179)) (length (hd (tl V2179)))) (shen.prolog-aritycheck V2178 (tl V2179)) (simple-error (cn "arity error in prolog procedure " (shen.app (cons V2178 ()) "
" shen.a))))) (true (shen.f_error shen.prolog-aritycheck))))

(defun shen.linearise-clause (V2181) (cond ((and (cons? V2181) (and (cons? (tl V2181)) (and (= :- (hd (tl V2181))) (and (cons? (tl (tl V2181))) (= () (tl (tl (tl V2181)))))))) (let Linear (shen.linearise (cons (hd V2181) (tl (tl V2181)))) (shen.clause_form Linear))) (true (shen.f_error shen.linearise-clause))))

(defun shen.clause_form (V2183) (cond ((and (cons? V2183) (and (cons? (tl V2183)) (= () (tl (tl V2183))))) (cons (shen.explicit_modes (hd V2183)) (cons :- (cons (shen.cf_help (hd (tl V2183))) ())))) (true (shen.f_error shen.clause_form))))

(defun shen.explicit_modes (V2185) (cond ((cons? V2185) (cons (hd V2185) (map (lambda X (shen.em_help X)) (tl V2185)))) (true (shen.f_error shen.explicit_modes))))

(defun shen.em_help (V2187) (cond ((and (cons? V2187) (and (= mode (hd V2187)) (and (cons? (tl V2187)) (and (cons? (tl (tl V2187))) (= () (tl (tl (tl V2187)))))))) V2187) (true (cons mode (cons V2187 (cons + ()))))))

(defun shen.cf_help (V2189) (cond ((and (cons? V2189) (and (= where (hd V2189)) (and (cons? (tl V2189)) (and (cons? (hd (tl V2189))) (and (= = (hd (hd (tl V2189)))) (and (cons? (tl (hd (tl V2189)))) (and (cons? (tl (tl (hd (tl V2189))))) (and (= () (tl (tl (tl (hd (tl V2189)))))) (and (cons? (tl (tl V2189))) (= () (tl (tl (tl V2189))))))))))))) (cons (cons (if (value shen.*occurs*) unify! unify) (tl (hd (tl V2189)))) (shen.cf_help (hd (tl (tl V2189)))))) (true V2189)))

(defun occurs-check (V2195) (cond ((= + V2195) (set shen.*occurs* true)) ((= - V2195) (set shen.*occurs* false)) (true (simple-error "occurs-check expects + or -
"))))

(defun shen.aum (V2198 V2199) (cond ((and (cons? V2198) (and (cons? (hd V2198)) (and (cons? (tl V2198)) (and (= :- (hd (tl V2198))) (and (cons? (tl (tl V2198))) (= () (tl (tl (tl V2198))))))))) (let MuApplication (shen.make_mu_application (cons shen.mu (cons (tl (hd V2198)) (cons (shen.continuation_call (tl (hd V2198)) (hd (tl (tl V2198)))) ()))) V2199) (shen.mu_reduction MuApplication +))) (true (shen.f_error shen.aum))))

(defun shen.continuation_call (V2202 V2203) (let VTerms (cons ProcessN (shen.extract_vars V2202)) (let VBody (shen.extract_vars V2203) (let Free (remove Throwcontrol (difference VBody VTerms)) (shen.cc_help Free V2203)))))

(defun remove (V2206 V2207) (shen.remove-h V2206 V2207 ()))

(defun shen.remove-h (V2214 V2215 V2216) (cond ((= () V2215) (reverse V2216)) ((and (cons? V2215) (= (hd V2215) V2214)) (shen.remove-h (hd V2215) (tl V2215) V2216)) ((cons? V2215) (shen.remove-h V2214 (tl V2215) (cons (hd V2215) V2216))) (true (shen.f_error shen.remove-h))))

(defun shen.cc_help (V2219 V2220) (cond ((and (= () V2219) (= () V2220)) (cons shen.pop (cons shen.the (cons shen.stack ())))) ((= () V2220) (cons shen.rename (cons shen.the (cons shen.variables (cons in (cons V2219 (cons and (cons shen.then (cons (cons shen.pop (cons shen.the (cons shen.stack ()))) ()))))))))) ((= () V2219) (cons call (cons shen.the (cons shen.continuation (cons V2220 ()))))) (true (cons shen.rename (cons shen.the (cons shen.variables (cons in (cons V2219 (cons and (cons shen.then (cons (cons call (cons shen.the (cons shen.continuation (cons V2220 ())))) ())))))))))))

(defun shen.make_mu_application (V2223 V2224) (cond ((and (cons? V2223) (and (= shen.mu (hd V2223)) (and (cons? (tl V2223)) (and (= () (hd (tl V2223))) (and (cons? (tl (tl V2223))) (and (= () (tl (tl (tl V2223)))) (= () V2224))))))) (hd (tl (tl V2223)))) ((and (cons? V2223) (and (= shen.mu (hd V2223)) (and (cons? (tl V2223)) (and (cons? (hd (tl V2223))) (and (cons? (tl (tl V2223))) (and (= () (tl (tl (tl V2223)))) (cons? V2224))))))) (cons (cons shen.mu (cons (hd (hd (tl V2223))) (cons (shen.make_mu_application (cons shen.mu (cons (tl (hd (tl V2223))) (tl (tl V2223)))) (tl V2224)) ()))) (cons (hd V2224) ()))) (true (shen.f_error shen.make_mu_application))))

(defun shen.mu_reduction (V2233 V2234) (cond ((and (cons? V2233) (and (cons? (hd V2233)) (and (= shen.mu (hd (hd V2233))) (and (cons? (tl (hd V2233))) (and (cons? (hd (tl (hd V2233)))) (and (= mode (hd (hd (tl (hd V2233))))) (and (cons? (tl (hd (tl (hd V2233))))) (and (cons? (tl (tl (hd (tl (hd V2233)))))) (and (= () (tl (tl (tl (hd (tl (hd V2233))))))) (and (cons? (tl (tl (hd V2233)))) (and (= () (tl (tl (tl (hd V2233))))) (and (cons? (tl V2233)) (= () (tl (tl V2233))))))))))))))) (shen.mu_reduction (cons (cons shen.mu (cons (hd (tl (hd (tl (hd V2233))))) (tl (tl (hd V2233))))) (tl V2233)) (hd (tl (tl (hd (tl (hd V2233)))))))) ((and (cons? V2233) (and (cons? (hd V2233)) (and (= shen.mu (hd (hd V2233))) (and (cons? (tl (hd V2233))) (and (cons? (tl (tl (hd V2233)))) (and (= () (tl (tl (tl (hd V2233))))) (and (cons? (tl V2233)) (and (= () (tl (tl V2233))) (= _ (hd (tl (hd V2233)))))))))))) (shen.mu_reduction (hd (tl (tl (hd V2233)))) V2234)) ((and (cons? V2233) (and (cons? (hd V2233)) (and (= shen.mu (hd (hd V2233))) (and (cons? (tl (hd V2233))) (and (cons? (tl (tl (hd V2233)))) (and (= () (tl (tl (tl (hd V2233))))) (and (cons? (tl V2233)) (and (= () (tl (tl V2233))) (shen.ephemeral_variable? (hd (tl (hd V2233))) (hd (tl V2233))))))))))) (subst (hd (tl V2233)) (hd (tl (hd V2233))) (shen.mu_reduction (hd (tl (tl (hd V2233)))) V2234))) ((and (cons? V2233) (and (cons? (hd V2233)) (and (= shen.mu (hd (hd V2233))) (and (cons? (tl (hd V2233))) (and (cons? (tl (tl (hd V2233)))) (and (= () (tl (tl (tl (hd V2233))))) (and (cons? (tl V2233)) (and (= () (tl (tl V2233))) (variable? (hd (tl (hd V2233)))))))))))) (cons let (cons (hd (tl (hd V2233))) (cons shen.be (cons (hd (tl V2233)) (cons in (cons (shen.mu_reduction (hd (tl (tl (hd V2233)))) V2234) ()))))))) ((and (cons? V2233) (and (cons? (hd V2233)) (and (= shen.mu (hd (hd V2233))) (and (cons? (tl (hd V2233))) (and (cons? (tl (tl (hd V2233)))) (and (= () (tl (tl (tl (hd V2233))))) (and (cons? (tl V2233)) (and (= () (tl (tl V2233))) (and (= - V2234) (shen.prolog_constant? (hd (tl (hd V2233))))))))))))) (let Z (gensym V) (cons let (cons Z (cons shen.be (cons (cons shen.the (cons shen.result (cons shen.of (cons shen.dereferencing (tl V2233))))) (cons in (cons (cons if (cons (cons Z (cons is (cons identical (cons shen.to (cons (hd (tl (hd V2233))) ()))))) (cons shen.then (cons (shen.mu_reduction (hd (tl (tl (hd V2233)))) -) (cons shen.else (cons shen.failed! ())))))) ())))))))) ((and (cons? V2233) (and (cons? (hd V2233)) (and (= shen.mu (hd (hd V2233))) (and (cons? (tl (hd V2233))) (and (cons? (tl (tl (hd V2233)))) (and (= () (tl (tl (tl (hd V2233))))) (and (cons? (tl V2233)) (and (= () (tl (tl V2233))) (and (= + V2234) (shen.prolog_constant? (hd (tl (hd V2233))))))))))))) (let Z (gensym V) (cons let (cons Z (cons shen.be (cons (cons shen.the (cons shen.result (cons shen.of (cons shen.dereferencing (tl V2233))))) (cons in (cons (cons if (cons (cons Z (cons is (cons identical (cons shen.to (cons (hd (tl (hd V2233))) ()))))) (cons shen.then (cons (shen.mu_reduction (hd (tl (tl (hd V2233)))) +) (cons shen.else (cons (cons if (cons (cons Z (cons is (cons shen.a (cons shen.variable ())))) (cons shen.then (cons (cons bind (cons Z (cons shen.to (cons (hd (tl (hd V2233))) (cons in (cons (shen.mu_reduction (hd (tl (tl (hd V2233)))) +) ())))))) (cons shen.else (cons shen.failed! ())))))) ())))))) ())))))))) ((and (cons? V2233) (and (cons? (hd V2233)) (and (= shen.mu (hd (hd V2233))) (and (cons? (tl (hd V2233))) (and (cons? (hd (tl (hd V2233)))) (and (cons? (tl (tl (hd V2233)))) (and (= () (tl (tl (tl (hd V2233))))) (and (cons? (tl V2233)) (and (= () (tl (tl V2233))) (= - V2234)))))))))) (let Z (gensym V) (cons let (cons Z (cons shen.be (cons (cons shen.the (cons shen.result (cons shen.of (cons shen.dereferencing (tl V2233))))) (cons in (cons (cons if (cons (cons Z (cons is (cons shen.a (cons shen.non-empty (cons list ()))))) (cons shen.then (cons (shen.mu_reduction (cons (cons shen.mu (cons (hd (hd (tl (hd V2233)))) (cons (cons (cons shen.mu (cons (tl (hd (tl (hd V2233)))) (tl (tl (hd V2233))))) (cons (cons shen.the (cons tail (cons shen.of (cons Z ())))) ())) ()))) (cons (cons shen.the (cons head (cons shen.of (cons Z ())))) ())) -) (cons shen.else (cons shen.failed! ())))))) ())))))))) ((and (cons? V2233) (and (cons? (hd V2233)) (and (= shen.mu (hd (hd V2233))) (and (cons? (tl (hd V2233))) (and (cons? (hd (tl (hd V2233)))) (and (cons? (tl (tl (hd V2233)))) (and (= () (tl (tl (tl (hd V2233))))) (and (cons? (tl V2233)) (and (= () (tl (tl V2233))) (= + V2234)))))))))) (let Z (gensym V) (cons let (cons Z (cons shen.be (cons (cons shen.the (cons shen.result (cons shen.of (cons shen.dereferencing (tl V2233))))) (cons in (cons (cons if (cons (cons Z (cons is (cons shen.a (cons shen.non-empty (cons list ()))))) (cons shen.then (cons (shen.mu_reduction (cons (cons shen.mu (cons (hd (hd (tl (hd V2233)))) (cons (cons (cons shen.mu (cons (tl (hd (tl (hd V2233)))) (tl (tl (hd V2233))))) (cons (cons shen.the (cons tail (cons shen.of (cons Z ())))) ())) ()))) (cons (cons shen.the (cons head (cons shen.of (cons Z ())))) ())) +) (cons shen.else (cons (cons if (cons (cons Z (cons is (cons shen.a (cons shen.variable ())))) (cons shen.then (cons (cons shen.rename (cons shen.the (cons shen.variables (cons in (cons (shen.extract_vars (hd (tl (hd V2233)))) (cons and (cons shen.then (cons (cons bind (cons Z (cons shen.to (cons (shen.rcons_form (shen.remove_modes (hd (tl (hd V2233))))) (cons in (cons (shen.mu_reduction (hd (tl (tl (hd V2233)))) +) ())))))) ())))))))) (cons shen.else (cons shen.failed! ())))))) ())))))) ())))))))) (true V2233)))

(defun shen.rcons_form (V2236) (cond ((cons? V2236) (cons cons (cons (shen.rcons_form (hd V2236)) (cons (shen.rcons_form (tl V2236)) ())))) (true V2236)))

(defun shen.remove_modes (V2238) (cond ((and (cons? V2238) (and (= mode (hd V2238)) (and (cons? (tl V2238)) (and (cons? (tl (tl V2238))) (and (= + (hd (tl (tl V2238)))) (= () (tl (tl (tl V2238))))))))) (shen.remove_modes (hd (tl V2238)))) ((and (cons? V2238) (and (= mode (hd V2238)) (and (cons? (tl V2238)) (and (cons? (tl (tl V2238))) (and (= - (hd (tl (tl V2238)))) (= () (tl (tl (tl V2238))))))))) (shen.remove_modes (hd (tl V2238)))) ((cons? V2238) (cons (shen.remove_modes (hd V2238)) (shen.remove_modes (tl V2238)))) (true V2238)))

(defun shen.ephemeral_variable? (V2241 V2242) (and (variable? V2241) (variable? V2242)))

(defun shen.prolog_constant? (V2252) (cond ((cons? V2252) false) (true true)))

(defun shen.aum_to_shen (V2254) (cond ((and (cons? V2254) (and (= let (hd V2254)) (and (cons? (tl V2254)) (and (cons? (tl (tl V2254))) (and (= shen.be (hd (tl (tl V2254)))) (and (cons? (tl (tl (tl V2254)))) (and (cons? (tl (tl (tl (tl V2254))))) (and (= in (hd (tl (tl (tl (tl V2254)))))) (and (cons? (tl (tl (tl (tl (tl V2254)))))) (= () (tl (tl (tl (tl (tl (tl V2254)))))))))))))))) (cons let (cons (hd (tl V2254)) (cons (shen.aum_to_shen (hd (tl (tl (tl V2254))))) (cons (shen.aum_to_shen (hd (tl (tl (tl (tl (tl V2254))))))) ()))))) ((and (cons? V2254) (and (= shen.the (hd V2254)) (and (cons? (tl V2254)) (and (= shen.result (hd (tl V2254))) (and (cons? (tl (tl V2254))) (and (= shen.of (hd (tl (tl V2254)))) (and (cons? (tl (tl (tl V2254)))) (and (= shen.dereferencing (hd (tl (tl (tl V2254))))) (and (cons? (tl (tl (tl (tl V2254))))) (= () (tl (tl (tl (tl (tl V2254))))))))))))))) (cons shen.lazyderef (cons (shen.aum_to_shen (hd (tl (tl (tl (tl V2254)))))) (cons ProcessN ())))) ((and (cons? V2254) (and (= if (hd V2254)) (and (cons? (tl V2254)) (and (cons? (tl (tl V2254))) (and (= shen.then (hd (tl (tl V2254)))) (and (cons? (tl (tl (tl V2254)))) (and (cons? (tl (tl (tl (tl V2254))))) (and (= shen.else (hd (tl (tl (tl (tl V2254)))))) (and (cons? (tl (tl (tl (tl (tl V2254)))))) (= () (tl (tl (tl (tl (tl (tl V2254)))))))))))))))) (cons if (cons (shen.aum_to_shen (hd (tl V2254))) (cons (shen.aum_to_shen (hd (tl (tl (tl V2254))))) (cons (shen.aum_to_shen (hd (tl (tl (tl (tl (tl V2254))))))) ()))))) ((and (cons? V2254) (and (cons? (tl V2254)) (and (= is (hd (tl V2254))) (and (cons? (tl (tl V2254))) (and (= shen.a (hd (tl (tl V2254)))) (and (cons? (tl (tl (tl V2254)))) (and (= shen.variable (hd (tl (tl (tl V2254))))) (= () (tl (tl (tl (tl V2254)))))))))))) (cons shen.pvar? (cons (hd V2254) ()))) ((and (cons? V2254) (and (cons? (tl V2254)) (and (= is (hd (tl V2254))) (and (cons? (tl (tl V2254))) (and (= shen.a (hd (tl (tl V2254)))) (and (cons? (tl (tl (tl V2254)))) (and (= shen.non-empty (hd (tl (tl (tl V2254))))) (and (cons? (tl (tl (tl (tl V2254))))) (and (= list (hd (tl (tl (tl (tl V2254)))))) (= () (tl (tl (tl (tl (tl V2254))))))))))))))) (cons cons? (cons (hd V2254) ()))) ((and (cons? V2254) (and (= shen.rename (hd V2254)) (and (cons? (tl V2254)) (and (= shen.the (hd (tl V2254))) (and (cons? (tl (tl V2254))) (and (= shen.variables (hd (tl (tl V2254)))) (and (cons? (tl (tl (tl V2254)))) (and (= in (hd (tl (tl (tl V2254))))) (and (cons? (tl (tl (tl (tl V2254))))) (and (= () (hd (tl (tl (tl (tl V2254)))))) (and (cons? (tl (tl (tl (tl (tl V2254)))))) (and (= and (hd (tl (tl (tl (tl (tl V2254))))))) (and (cons? (tl (tl (tl (tl (tl (tl V2254))))))) (and (= shen.then (hd (tl (tl (tl (tl (tl (tl V2254)))))))) (and (cons? (tl (tl (tl (tl (tl (tl (tl V2254)))))))) (= () (tl (tl (tl (tl (tl (tl (tl (tl V2254)))))))))))))))))))))))) (shen.aum_to_shen (hd (tl (tl (tl (tl (tl (tl (tl V2254)))))))))) ((and (cons? V2254) (and (= shen.rename (hd V2254)) (and (cons? (tl V2254)) (and (= shen.the (hd (tl V2254))) (and (cons? (tl (tl V2254))) (and (= shen.variables (hd (tl (tl V2254)))) (and (cons? (tl (tl (tl V2254)))) (and (= in (hd (tl (tl (tl V2254))))) (and (cons? (tl (tl (tl (tl V2254))))) (and (cons? (hd (tl (tl (tl (tl V2254)))))) (and (cons? (tl (tl (tl (tl (tl V2254)))))) (and (= and (hd (tl (tl (tl (tl (tl V2254))))))) (and (cons? (tl (tl (tl (tl (tl (tl V2254))))))) (and (= shen.then (hd (tl (tl (tl (tl (tl (tl V2254)))))))) (and (cons? (tl (tl (tl (tl (tl (tl (tl V2254)))))))) (= () (tl (tl (tl (tl (tl (tl (tl (tl V2254)))))))))))))))))))))))) (cons let (cons (hd (hd (tl (tl (tl (tl V2254)))))) (cons (cons shen.newpv (cons ProcessN ())) (cons (shen.aum_to_shen (cons shen.rename (cons shen.the (cons shen.variables (cons in (cons (tl (hd (tl (tl (tl (tl V2254)))))) (tl (tl (tl (tl (tl V2254))))))))))) ()))))) ((and (cons? V2254) (and (= bind (hd V2254)) (and (cons? (tl V2254)) (and (cons? (tl (tl V2254))) (and (= shen.to (hd (tl (tl V2254)))) (and (cons? (tl (tl (tl V2254)))) (and (cons? (tl (tl (tl (tl V2254))))) (and (= in (hd (tl (tl (tl (tl V2254)))))) (and (cons? (tl (tl (tl (tl (tl V2254)))))) (= () (tl (tl (tl (tl (tl (tl V2254)))))))))))))))) (cons do (cons (cons shen.bindv (cons (hd (tl V2254)) (cons (shen.chwild (hd (tl (tl (tl V2254))))) (cons ProcessN ())))) (cons (cons let (cons Result (cons (shen.aum_to_shen (hd (tl (tl (tl (tl (tl V2254))))))) (cons (cons do (cons (cons shen.unbindv (cons (hd (tl V2254)) (cons ProcessN ()))) (cons Result ()))) ())))) ())))) ((and (cons? V2254) (and (cons? (tl V2254)) (and (= is (hd (tl V2254))) (and (cons? (tl (tl V2254))) (and (= identical (hd (tl (tl V2254)))) (and (cons? (tl (tl (tl V2254)))) (and (= shen.to (hd (tl (tl (tl V2254))))) (and (cons? (tl (tl (tl (tl V2254))))) (= () (tl (tl (tl (tl (tl V2254)))))))))))))) (cons = (cons (hd (tl (tl (tl (tl V2254))))) (cons (hd V2254) ())))) ((= shen.failed! V2254) false) ((and (cons? V2254) (and (= shen.the (hd V2254)) (and (cons? (tl V2254)) (and (= head (hd (tl V2254))) (and (cons? (tl (tl V2254))) (and (= shen.of (hd (tl (tl V2254)))) (and (cons? (tl (tl (tl V2254)))) (= () (tl (tl (tl (tl V2254)))))))))))) (cons hd (tl (tl (tl V2254))))) ((and (cons? V2254) (and (= shen.the (hd V2254)) (and (cons? (tl V2254)) (and (= tail (hd (tl V2254))) (and (cons? (tl (tl V2254))) (and (= shen.of (hd (tl (tl V2254)))) (and (cons? (tl (tl (tl V2254)))) (= () (tl (tl (tl (tl V2254)))))))))))) (cons tl (tl (tl (tl V2254))))) ((and (cons? V2254) (and (= shen.pop (hd V2254)) (and (cons? (tl V2254)) (and (= shen.the (hd (tl V2254))) (and (cons? (tl (tl V2254))) (and (= shen.stack (hd (tl (tl V2254)))) (= () (tl (tl (tl V2254)))))))))) (cons do (cons (cons shen.incinfs ()) (cons (cons thaw (cons Continuation ())) ())))) ((and (cons? V2254) (and (= call (hd V2254)) (and (cons? (tl V2254)) (and (= shen.the (hd (tl V2254))) (and (cons? (tl (tl V2254))) (and (= shen.continuation (hd (tl (tl V2254)))) (and (cons? (tl (tl (tl V2254)))) (= () (tl (tl (tl (tl V2254)))))))))))) (cons do (cons (cons shen.incinfs ()) (cons (shen.call_the_continuation (shen.chwild (hd (tl (tl (tl V2254))))) ProcessN Continuation) ())))) (true V2254)))

(defun shen.chwild (V2256) (cond ((= V2256 _) (cons shen.newpv (cons ProcessN ()))) ((cons? V2256) (map (lambda Z (shen.chwild Z)) V2256)) (true V2256)))

(defun shen.newpv (V2258) (let Count+1 (+ (<-address (value shen.*varcounter*) V2258) 1) (let IncVar (address-> (value shen.*varcounter*) V2258 Count+1) (let Vector (<-address (value shen.*prologvectors*) V2258) (let ResizeVectorIfNeeded (if (= Count+1 (limit Vector)) (shen.resizeprocessvector V2258 Count+1) shen.skip) (shen.mk-pvar Count+1))))))

(defun shen.resizeprocessvector (V2261 V2262) (let Vector (<-address (value shen.*prologvectors*) V2261) (let BigVector (shen.resize-vector Vector (+ V2262 V2262) shen.-null-) (address-> (value shen.*prologvectors*) V2261 BigVector))))

(defun shen.resize-vector (V2266 V2267 V2268) (let BigVector (address-> (absvector (+ 1 V2267)) 0 V2267) (shen.copy-vector V2266 BigVector (limit V2266) V2267 V2268)))

(defun shen.copy-vector (V2274 V2275 V2276 V2277 V2278) (shen.copy-vector-stage-2 (+ 1 V2276) (+ V2277 1) V2278 (shen.copy-vector-stage-1 1 V2274 V2275 (+ 1 V2276))))

(defun shen.copy-vector-stage-1 (V2286 V2287 V2288 V2289) (cond ((= V2289 V2286) V2288) (true (shen.copy-vector-stage-1 (+ 1 V2286) V2287 (address-> V2288 V2286 (<-address V2287 V2286)) V2289))))

(defun shen.copy-vector-stage-2 (V2297 V2298 V2299 V2300) (cond ((= V2298 V2297) V2300) (true (shen.copy-vector-stage-2 (+ V2297 1) V2298 V2299 (address-> V2300 V2297 V2299)))))

(defun shen.mk-pvar (V2302) (address-> (address-> (absvector 2) 0 shen.pvar) 1 V2302))

(defun shen.pvar? (V2304) (and (absvector? V2304) (= (trap-error (<-address V2304 0) (lambda E shen.not-pvar)) shen.pvar)))

(defun shen.bindv (V2308 V2309 V2310) (let Vector (<-address (value shen.*prologvectors*) V2310) (address-> Vector (<-address V2308 1) V2309)))

(defun shen.unbindv (V2313 V2314) (let Vector (<-address (value shen.*prologvectors*) V2314) (address-> Vector (<-address V2313 1) shen.-null-)))

(defun shen.incinfs () (set shen.*infs* (+ 1 (value shen.*infs*))))

(defun shen.call_the_continuation (V2318 V2319 V2320) (cond ((and (cons? V2318) (and (cons? (hd V2318)) (= () (tl V2318)))) (cons (hd (hd V2318)) (append (tl (hd V2318)) (cons V2319 (cons V2320 ()))))) ((and (cons? V2318) (cons? (hd V2318))) (let NewContinuation (shen.newcontinuation (tl V2318) V2319 V2320) (cons (hd (hd V2318)) (append (tl (hd V2318)) (cons V2319 (cons NewContinuation ())))))) (true (shen.f_error shen.call_the_continuation))))

(defun shen.newcontinuation (V2324 V2325 V2326) (cond ((= () V2324) V2326) ((and (cons? V2324) (cons? (hd V2324))) (cons freeze (cons (cons (hd (hd V2324)) (append (tl (hd V2324)) (cons V2325 (cons (shen.newcontinuation (tl V2324) V2325 V2326) ())))) ()))) (true (shen.f_error shen.newcontinuation))))

(defun return (V2334 V2335 V2336) (shen.deref V2334 V2335))

(defun shen.measure&return (V2344 V2345 V2346) (do (shen.prhush (shen.app (value shen.*infs*) " inferences
" shen.a) (stoutput)) (shen.deref V2344 V2345)))

(defun unify (V2351 V2352 V2353 V2354) (shen.lzy= (shen.lazyderef V2351 V2353) (shen.lazyderef V2352 V2353) V2353 V2354))

(defun shen.lzy= (V2376 V2377 V2378 V2379) (cond ((= V2377 V2376) (thaw V2379)) ((shen.pvar? V2376) (bind V2376 V2377 V2378 V2379)) ((shen.pvar? V2377) (bind V2377 V2376 V2378 V2379)) ((and (cons? V2376) (cons? V2377)) (shen.lzy= (shen.lazyderef (hd V2376) V2378) (shen.lazyderef (hd V2377) V2378) V2378 (freeze (shen.lzy= (shen.lazyderef (tl V2376) V2378) (shen.lazyderef (tl V2377) V2378) V2378 V2379)))) (true false)))

(defun shen.deref (V2382 V2383) (cond ((cons? V2382) (cons (shen.deref (hd V2382) V2383) (shen.deref (tl V2382) V2383))) (true (if (shen.pvar? V2382) (let Value (shen.valvector V2382 V2383) (if (= Value shen.-null-) V2382 (shen.deref Value V2383))) V2382))))

(defun shen.lazyderef (V2386 V2387) (if (shen.pvar? V2386) (let Value (shen.valvector V2386 V2387) (if (= Value shen.-null-) V2386 (shen.lazyderef Value V2387))) V2386))

(defun shen.valvector (V2390 V2391) (<-address (<-address (value shen.*prologvectors*) V2391) (<-address V2390 1)))

(defun unify! (V2396 V2397 V2398 V2399) (shen.lzy=! (shen.lazyderef V2396 V2398) (shen.lazyderef V2397 V2398) V2398 V2399))

(defun shen.lzy=! (V2421 V2422 V2423 V2424) (cond ((= V2422 V2421) (thaw V2424)) ((and (shen.pvar? V2421) (not (shen.occurs? V2421 (shen.deref V2422 V2423)))) (bind V2421 V2422 V2423 V2424)) ((and (shen.pvar? V2422) (not (shen.occurs? V2422 (shen.deref V2421 V2423)))) (bind V2422 V2421 V2423 V2424)) ((and (cons? V2421) (cons? V2422)) (shen.lzy=! (shen.lazyderef (hd V2421) V2423) (shen.lazyderef (hd V2422) V2423) V2423 (freeze (shen.lzy=! (shen.lazyderef (tl V2421) V2423) (shen.lazyderef (tl V2422) V2423) V2423 V2424)))) (true false)))

(defun shen.occurs? (V2436 V2437) (cond ((= V2437 V2436) true) ((cons? V2437) (or (shen.occurs? V2436 (hd V2437)) (shen.occurs? V2436 (tl V2437)))) (true false)))

(defun identical (V2442 V2443 V2444 V2445) (shen.lzy== (shen.lazyderef V2442 V2444) (shen.lazyderef V2443 V2444) V2444 V2445))

(defun shen.lzy== (V2467 V2468 V2469 V2470) (cond ((= V2468 V2467) (thaw V2470)) ((and (cons? V2467) (cons? V2468)) (shen.lzy== (shen.lazyderef (hd V2467) V2469) (shen.lazyderef (hd V2468) V2469) V2469 (freeze (shen.lzy== (tl V2467) (tl V2468) V2469 V2470)))) (true false)))

(defun shen.pvar (V2472) (cn "Var" (shen.app (<-address V2472 1) "" shen.a)))

(defun bind (V2477 V2478 V2479 V2480) (do (shen.bindv V2477 V2478 V2479) (let Result (thaw V2480) (do (shen.unbindv V2477 V2479) Result))))

(defun fwhen (V2498 V2499 V2500) (cond ((= true V2498) (thaw V2500)) ((= false V2498) false) (true (simple-error (cn "fwhen expects a boolean: not " (shen.app V2498 "%" shen.s))))))

(defun call (V2516 V2517 V2518) (cond ((cons? V2516) (shen.call-help (function (shen.lazyderef (hd V2516) V2517)) (tl V2516) V2517 V2518)) ((shen.pvar? V2516) (call (shen.lazyderef V2516 V2517) V2517 V2518)) (true false)))

(defun shen.call-help (V2523 V2524 V2525 V2526) (cond ((= () V2524) (V2523 V2525 V2526)) ((cons? V2524) (shen.call-help (V2523 (hd V2524)) (tl V2524) V2525 V2526)) (true (shen.f_error shen.call-help))))

(defun shen.intprolog (V2528) (cond ((and (cons? V2528) (cons? (hd V2528))) (let ProcessN (shen.start-new-prolog-process) (shen.intprolog-help (hd (hd V2528)) (shen.insert-prolog-variables (cons (tl (hd V2528)) (cons (tl V2528) ())) ProcessN) ProcessN))) (true (shen.f_error shen.intprolog))))

(defun shen.intprolog-help (V2532 V2533 V2534) (cond ((and (cons? V2533) (and (cons? (tl V2533)) (= () (tl (tl V2533))))) (shen.intprolog-help-help V2532 (hd V2533) (hd (tl V2533)) V2534)) (true (shen.f_error shen.intprolog-help))))

(defun shen.intprolog-help-help (V2539 V2540 V2541 V2542) (cond ((= () V2540) (V2539 V2542 (freeze (shen.call-rest V2541 V2542)))) ((cons? V2540) (shen.intprolog-help-help (V2539 (hd V2540)) (tl V2540) V2541 V2542)) (true (shen.f_error shen.intprolog-help-help))))

(defun shen.call-rest (V2547 V2548) (cond ((= () V2547) true) ((and (cons? V2547) (and (cons? (hd V2547)) (cons? (tl (hd V2547))))) (shen.call-rest (cons (cons ((hd (hd V2547)) (hd (tl (hd V2547)))) (tl (tl (hd V2547)))) (tl V2547)) V2548)) ((and (cons? V2547) (and (cons? (hd V2547)) (= () (tl (hd V2547))))) ((hd (hd V2547)) V2548 (freeze (shen.call-rest (tl V2547) V2548)))) (true (shen.f_error shen.call-rest))))

(defun shen.start-new-prolog-process () (let IncrementProcessCounter (set shen.*process-counter* (+ 1 (value shen.*process-counter*))) (shen.initialise-prolog IncrementProcessCounter)))

(defun shen.insert-prolog-variables (V2551 V2552) (shen.insert-prolog-variables-help V2551 (shen.flatten V2551) V2552))

(defun shen.insert-prolog-variables-help (V2560 V2561 V2562) (cond ((= () V2561) V2560) ((and (cons? V2561) (variable? (hd V2561))) (let V (shen.newpv V2562) (let XV/Y (subst V (hd V2561) V2560) (let Z-Y (remove (hd V2561) (tl V2561)) (shen.insert-prolog-variables-help XV/Y Z-Y V2562))))) ((cons? V2561) (shen.insert-prolog-variables-help V2560 (tl V2561) V2562)) (true (shen.f_error shen.insert-prolog-variables-help))))

(defun shen.initialise-prolog (V2564) (let Vector (address-> (value shen.*prologvectors*) V2564 (shen.fillvector (vector 10) 1 10 shen.-null-)) (let Counter (address-> (value shen.*varcounter*) V2564 1) V2564)))



